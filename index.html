import os
import time
import json
import logging
from datetime import datetime, timedelta
from pathlib import Path
from playwright.sync_api import sync_playwright, TimeoutError
import random

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('youtube_uploader.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class YouTubeUploader:
    def __init__(self, upload_dir="upload_queue", auth_file="auth.json"):
        self.upload_dir = Path(upload_dir)
        self.auth_file = auth_file
        self.upload_dir.mkdir(exist_ok=True)
        self.browser = None
        self.context = None
        self.page = None
        
        # ì—…ë¡œë“œ ì„¤ì •
        self.settings = {
            'privacy': 'private',  # public, unlisted, private
            'category': 'Entertainment',
            'language': 'Korean',
            'auto_chapters': True,
            'auto_captions': True,
            'comments_allowed': True,
            'age_restriction': False
        }
    
    def human_delay(self, min_ms=500, max_ms=2000):
        """ì‚¬ëŒì²˜ëŸ¼ ìì—°ìŠ¤ëŸ¬ìš´ ë”œë ˆì´"""
        delay = random.uniform(min_ms, max_ms) / 1000
        time.sleep(delay)
    
    def safe_click(self, element, description="element", timeout=10000):
        """ì•ˆì „í•œ í´ë¦­"""
        try:
            element.wait_for(state="visible", timeout=timeout)
            element.click()
            logger.info(f"âœ… Clicked {description}")
            return True
        except TimeoutError:
            logger.warning(f"âš ï¸ Timeout waiting for {description}")
            try:
                element.click(force=True)
                logger.info(f"âœ… Force clicked {description}")
                return True
            except:
                try:
                    element.evaluate("el => el.click()")
                    logger.info(f"âœ… JS clicked {description}")
                    return True
                except Exception as e:
                    logger.error(f"âŒ Failed to click {description}: {e}")
                    return False
        except Exception as e:
            logger.error(f"âŒ Click error {description}: {e}")
            return False
    
    def setup_browser(self, headless=False):
        """ë¸Œë¼ìš°ì € ì„¤ì •"""
        logger.info("ğŸŒ Setting up browser...")
        
        try:
            playwright = sync_playwright().start()
            self.browser = playwright.chromium.launch(
                headless=headless,
                args=[
                    '--no-sandbox',
                    '--disable-blink-features=AutomationControlled',
                    '--disable-web-security'
                ]
            )
            
            context_options = {
                'viewport': {'width': 1920, 'height': 1080},
                'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            }
            
            if os.path.exists(self.auth_file):
                context_options['storage_state'] = self.auth_file
                logger.info("ğŸ”‘ Loaded authentication")
            
            self.context = self.browser.new_context(**context_options)
            
            # ìë™í™” ê°ì§€ ë°©ì§€
            self.context.add_init_script("""
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => undefined,
                });
                window.chrome = { runtime: {} };
            """)
            
            self.page = self.context.new_page()
            self.page.on("dialog", lambda dialog: dialog.accept())
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ Browser setup failed: {e}")
            return False
    
    def authenticate(self):
        """YouTube ì¸ì¦"""
        if os.path.exists(self.auth_file):
            logger.info("ğŸ”‘ Using existing authentication")
            return True
        
        logger.info("ğŸ” Starting authentication...")
        
        try:
            self.page.goto("https://studio.youtube.com", wait_until="domcontentloaded")
            self.human_delay(3000, 5000)
            
            print("\n" + "="*60)
            print("ğŸ” YOUTUBE LOGIN REQUIRED")
            print("="*60)
            print("1. êµ¬ê¸€ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì„¸ìš”")
            print("2. YouTube Studio ë©”ì¸ í˜ì´ì§€ê°€ ë¡œë“œë˜ë©´ Enterë¥¼ ëˆ„ë¥´ì„¸ìš”")
            print("="*60)
            
            input("ë¡œê·¸ì¸ ì™„ë£Œ í›„ Enterë¥¼ ëˆ„ë¥´ì„¸ìš”...")
            
            self.context.storage_state(path=self.auth_file)
            logger.info(f"âœ… Authentication saved")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Authentication failed: {e}")
            return False
    
    def navigate_to_upload(self):
        """ì—…ë¡œë“œ í˜ì´ì§€ë¡œ ì´ë™"""
        logger.info("ğŸ“¤ Navigating to upload...")
        
        try:
            self.page.goto("https://studio.youtube.com", wait_until="domcontentloaded")
            self.human_delay(3000, 5000)
            
            # CREATE ë²„íŠ¼ ì°¾ê¸° ë° í´ë¦­
            create_selectors = [
                '[aria-label="ë§Œë“¤ê¸°"]',
                '[aria-label="Create"]',
                'button:has-text("CREATE")',
                '#create-icon'
            ]
            
            for selector in create_selectors:
                try:
                    create_btn = self.page.locator(selector).first
                    if create_btn.is_visible(timeout=5000):
                        self.safe_click(create_btn, "Create button")
                        break
                except:
                    continue
            
            self.human_delay(1000, 2000)
            
            # ì—…ë¡œë“œ ì˜µì…˜ í´ë¦­
            upload_selectors = [
                'text="ë™ì˜ìƒ ì—…ë¡œë“œ"',
                'text="Upload video"',
                'text="Upload videos"'
            ]
            
            for selector in upload_selectors:
                try:
                    upload_btn = self.page.locator(selector).first
                    if upload_btn.is_visible(timeout=5000):
                        self.safe_click(upload_btn, "Upload video")
                        break
                except:
                    continue
            
            self.human_delay(2000, 3000)
            return True
            
        except Exception as e:
            logger.error(f"âŒ Navigation failed: {e}")
            return False
    
    def upload_file(self, video_path):
        """ë¹„ë””ì˜¤ íŒŒì¼ ì—…ë¡œë“œ"""
        logger.info(f"ğŸ“ Uploading: {video_path}")
        
        try:
            # íŒŒì¼ ì…ë ¥ ìš”ì†Œ ì°¾ê¸°
            file_input = self.page.locator('input[type="file"]').first
            file_input.set_input_files(str(video_path))
            logger.info("âœ… Video file uploaded")
            
            # ì—…ë¡œë“œ ì‹œì‘ ëŒ€ê¸°
            self.human_delay(5000, 8000)
            return True
            
        except Exception as e:
            logger.error(f"âŒ File upload failed: {e}")
            return False
    
    def wait_for_upload_processing(self):
        """ì—…ë¡œë“œ ì²˜ë¦¬ ì™„ë£Œ ëŒ€ê¸°"""
        logger.info("â³ Waiting for upload processing...")
        
        max_wait = 300  # 5ë¶„
        start_time = time.time()
        
        while time.time() - start_time < max_wait:
            try:
                # ì²˜ë¦¬ ì™„ë£Œ í™•ì¸
                if self.page.locator('text="ì²˜ë¦¬ ì™„ë£Œ"').count() > 0:
                    logger.info("âœ… Upload processing complete")
                    return True
                
                if self.page.locator('text="Upload complete"').count() > 0:
                    logger.info("âœ… Upload complete")
                    return True
                
                # ì§„í–‰ë¥  í™•ì¸
                progress = self.page.locator('.progress-label').first
                if progress.is_visible():
                    text = progress.inner_text()
                    if "%" in text:
                        logger.info(f"ğŸ“¤ Progress: {text}")
                
                time.sleep(5)
                
            except:
                time.sleep(5)
        
        logger.warning("âš ï¸ Upload processing timeout")
        return True  # íƒ€ì„ì•„ì›ƒì´ì–´ë„ ê³„ì† ì§„í–‰
    
    def fill_metadata(self, title, description, thumbnail_path=None):
        """ë©”íƒ€ë°ì´í„° ì…ë ¥"""
        logger.info("ğŸ“ Filling metadata...")
        
        try:
            # ì œëª© ì…ë ¥
            title_selectors = [
                '[aria-label="ì œëª©"]',
                '[aria-label="Title"]',
                '#textbox'
            ]
            
            for selector in title_selectors:
                try:
                    title_field = self.page.locator(selector).first
                    if title_field.is_visible(timeout=5000):
                        title_field.click()
                        title_field.press("Control+a")
                        title_field.type(title, delay=50)
                        logger.info(f"âœ… Title set: {title[:30]}...")
                        break
                except:
                    continue
            
            self.human_delay(1000, 2000)
            
            # ì„¤ëª… ì…ë ¥
            desc_selectors = [
                '[aria-label="ì„¤ëª…"]',
                '[aria-label="Description"]',
                '#textbox >> nth=1'
            ]
            
            for selector in desc_selectors:
                try:
                    desc_field = self.page.locator(selector).first
                    if desc_field.is_visible(timeout=5000):
                        desc_field.click()
                        desc_field.type(description, delay=30)
                        logger.info("âœ… Description set")
                        break
                except:
                    continue
            
            # ì¸ë„¤ì¼ ì—…ë¡œë“œ
            if thumbnail_path and Path(thumbnail_path).exists():
                self.upload_thumbnail(thumbnail_path)
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ Metadata fill failed: {e}")
            return False
    
    def upload_thumbnail(self, thumbnail_path):
        """ì¸ë„¤ì¼ ì—…ë¡œë“œ"""
        logger.info(f"ğŸ–¼ï¸ Uploading thumbnail...")
        
        try:
            # ì¸ë„¤ì¼ ì—…ë¡œë“œ ë²„íŠ¼ ì°¾ê¸°
            thumb_selectors = [
                'text="ì¸ë„¤ì¼ ì—…ë¡œë“œ"',
                'text="Upload thumbnail"',
                'input[accept*="image"]'
            ]
            
            for selector in thumb_selectors:
                try:
                    if "input" in selector:
                        thumb_input = self.page.locator(selector).first
                        thumb_input.set_input_files(str(thumbnail_path))
                    else:
                        thumb_btn = self.page.locator(selector).first
                        if thumb_btn.is_visible(timeout=3000):
                            thumb_btn.click()
                            self.human_delay(1000, 2000)
                            # íŒŒì¼ ì…ë ¥
                            file_input = self.page.locator('input[type="file"]').last
                            file_input.set_input_files(str(thumbnail_path))
                    
                    logger.info("âœ… Thumbnail uploaded")
                    return True
                except:
                    continue
            
            logger.warning("âš ï¸ Thumbnail upload skipped")
            return False
            
        except Exception as e:
            logger.warning(f"âš ï¸ Thumbnail upload failed: {e}")
            return False
    
    def navigate_through_steps(self):
        """ì—…ë¡œë“œ ë‹¨ê³„ ì§„í–‰"""
        logger.info("â¡ï¸ Navigating through upload steps...")
        
        try:
            # ë‹¤ìŒ ë²„íŠ¼ 3ë²ˆ í´ë¦­
            for step in range(3):
                next_selectors = [
                    'text="ë‹¤ìŒ"',
                    'text="Next"',
                    '[aria-label="ë‹¤ìŒ"]',
                    '[aria-label="Next"]'
                ]
                
                for selector in next_selectors:
                    try:
                        next_btn = self.page.locator(selector).first
                        if next_btn.is_visible(timeout=5000):
                            self.safe_click(next_btn, f"Next step {step+1}")
                            self.human_delay(2000, 3000)
                            break
                    except:
                        continue
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ Step navigation failed: {e}")
            return False
    
    def set_privacy_and_schedule(self, privacy="private", schedule_datetime=None):
        """ê³µê°œ ì„¤ì • ë° ì˜ˆì•½"""
        logger.info(f"ğŸ”’ Setting privacy: {privacy}")
        
        try:
            # ê³µê°œ ì„¤ì •
            privacy_map = {
                'private': ['ë¹„ê³µê°œ', 'Private'],
                'unlisted': ['ëª©ë¡ì— ì—†ìŒ', 'Unlisted'],
                'public': ['ê³µê°œ', 'Public']
            }
            
            privacy_options = privacy_map.get(privacy, ['ë¹„ê³µê°œ', 'Private'])
            
            for privacy_text in privacy_options:
                try:
                    privacy_btn = self.page.locator(f'text="{privacy_text}"').first
                    if privacy_btn.is_visible(timeout=3000):
                        self.safe_click(privacy_btn, f"Privacy: {privacy_text}")
                        break
                except:
                    continue
            
            # ì˜ˆì•½ ì„¤ì •
            if schedule_datetime:
                logger.info(f"ğŸ“… Setting schedule: {schedule_datetime}")
                
                # ì˜ˆì•½ ë¼ë””ì˜¤ ë²„íŠ¼
                schedule_selectors = [
                    'text="ì˜ˆì•½"',
                    'text="Schedule"'
                ]
                
                for selector in schedule_selectors:
                    try:
                        schedule_radio = self.page.locator(selector).first
                        if schedule_radio.is_visible(timeout=3000):
                            self.safe_click(schedule_radio, "Schedule radio")
                            break
                    except:
                        continue
                
                self.human_delay(1000, 2000)
                
                # ë‚ ì§œ ì„¤ì •
                date_str = schedule_datetime.strftime("%Y-%m-%d")
                date_input = self.page.locator('input[type="date"]').first
                if date_input.is_visible(timeout=3000):
                    date_input.fill(date_str)
                
                # ì‹œê°„ ì„¤ì •
                time_str = schedule_datetime.strftime("%H:%M")
                time_input = self.page.locator('input[type="time"]').first
                if time_input.is_visible(timeout=3000):
                    time_input.fill(time_str)
                
                logger.info(f"âœ… Schedule set: {date_str} {time_str}")
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ Privacy/schedule setting failed: {e}")
            return False
    
    def publish_video(self, is_scheduled=False):
        """ë¹„ë””ì˜¤ ê²Œì‹œ"""
        action = "scheduled" if is_scheduled else "published"
        logger.info(f"ğŸš€ Publishing video ({action})...")
        
        try:
            publish_selectors = [
                'text="ì˜ˆì•½"' if is_scheduled else 'text="ê²Œì‹œ"',
                'text="Schedule"' if is_scheduled else 'text="Publish"',
                'button:has-text("ì˜ˆì•½")' if is_scheduled else 'button:has-text("ê²Œì‹œ")',
                'button:has-text("Schedule")' if is_scheduled else 'button:has-text("Publish")'
            ]
            
            for selector in publish_selectors:
                try:
                    publish_btn = self.page.locator(selector).first
                    if publish_btn.is_visible(timeout=10000):
                        self.safe_click(publish_btn, f"Publish ({action})")
                        self.human_delay(3000, 5000)
                        logger.info(f"âœ… Video {action} successfully!")
                        return True
                except:
                    continue
            
            logger.error("âŒ Publish button not found")
            return False
            
        except Exception as e:
            logger.error(f"âŒ Publishing failed: {e}")
            return False
    
    def upload_single_video(self, video_config):
        """ë‹¨ì¼ ë¹„ë””ì˜¤ ì—…ë¡œë“œ ì „ì²´ í”„ë¡œì„¸ìŠ¤"""
        video_id = video_config['id']
        logger.info(f"ğŸ¬ Starting upload: {video_id}")
        
        try:
            # 1. ì—…ë¡œë“œ í˜ì´ì§€ë¡œ ì´ë™
            if not self.navigate_to_upload():
                return False
            
            # 2. íŒŒì¼ ì—…ë¡œë“œ
            if not self.upload_file(video_config['video_path']):
                return False
            
            # 3. ì—…ë¡œë“œ ì²˜ë¦¬ ëŒ€ê¸°
            if not self.wait_for_upload_processing():
                logger.warning("âš ï¸ Processing timeout, continuing...")
            
            # 4. ë©”íƒ€ë°ì´í„° ì…ë ¥
            if not self.fill_metadata(
                video_config['title'],
                video_config['description'],
                video_config.get('thumbnail_path')
            ):
                return False
            
            # 5. ì—…ë¡œë“œ ë‹¨ê³„ ì§„í–‰
            if not self.navigate_through_steps():
                return False
            
            # 6. ê³µê°œ ì„¤ì • ë° ì˜ˆì•½
            if not self.set_privacy_and_schedule(
                self.settings['privacy'],
                video_config.get('schedule_datetime')
            ):
                return False
            
            # 7. ê²Œì‹œ
            is_scheduled = bool(video_config.get('schedule_datetime'))
            if not self.publish_video(is_scheduled):
                return False
            
            logger.info(f"âœ… {video_id} upload completed successfully!")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Upload failed for {video_id}: {e}")
            return False
    
    def load_video_configs(self):
        """ë¹„ë””ì˜¤ ì„¤ì • ë¡œë“œ"""
        configs = []
        video_files = list(self.upload_dir.glob("*_video.mp4"))
        
        for video_file in video_files:
            video_id = video_file.stem.replace("_video", "")
            
            try:
                title_file = self.upload_dir / f"{video_id}_title.txt"
                desc_file = self.upload_dir / f"{video_id}_description.txt"
                
                if not title_file.exists() or not desc_file.exists():
                    logger.warning(f"âš ï¸ Missing files for {video_id}")
                    continue
                
                config = {
                    'id': video_id,
                    'video_path': video_file,
                    'title': title_file.read_text(encoding='utf-8').strip(),
                    'description': desc_file.read_text(encoding='utf-8').strip()
                }
                
                # ì¸ë„¤ì¼
                thumbnail_file = self.upload_dir / f"{video_id}_thumbnail.jpg"
                if thumbnail_file.exists():
                    config['thumbnail_path'] = thumbnail_file
                
                # ì˜ˆì•½ ì‹œê°„
                schedule_file = self.upload_dir / f"{video_id}_schedule.txt"
                if schedule_file.exists():
                    schedule_str = schedule_file.read_text(encoding='utf-8').strip()
                    try:
                        config['schedule_datetime'] = datetime.strptime(schedule_str, "%Y-%m-%d %H:%M")
                    except ValueError:
                        logger.warning(f"âš ï¸ Invalid schedule format: {schedule_str}")
                
                configs.append(config)
                logger.info(f"ğŸ“‹ Loaded: {video_id}")
                
            except Exception as e:
                logger.error(f"âŒ Failed to load {video_id}: {e}")
        
        return configs
    
    def run(self, headless=False):
        """ë©”ì¸ ì‹¤í–‰"""
        logger.info("ğŸš€ Starting YouTube Auto Uploader...")
        
        try:
            # ë¸Œë¼ìš°ì € ì„¤ì •
            if not self.setup_browser(headless):
                return False
            
            # ì¸ì¦
            if not self.authenticate():
                return False
            
            # ë¹„ë””ì˜¤ ì„¤ì • ë¡œë“œ
            video_configs = self.load_video_configs()
            if not video_configs:
                logger.warning("âš ï¸ No videos found")
                return False
            
            logger.info(f"ğŸ“¹ Found {len(video_configs)} videos")
            
            # ì—…ë¡œë“œ ì‹¤í–‰
            success_count = 0
            for i, config in enumerate(video_configs):
                logger.info(f"ğŸ“¤ Processing {i+1}/{len(video_configs)}: {config['id']}")
                
                if self.upload_single_video(config):
                    success_count += 1
                
                # ë‹¤ìŒ ì—…ë¡œë“œ ì „ ëŒ€ê¸°
                if i < len(video_configs) - 1:
                    wait_time = random.uniform(60, 120)
                    logger.info(f"â³ Waiting {wait_time:.1f}s...")
                    time.sleep(wait_time)
            
            logger.info(f"ğŸ‰ Completed: {success_count}/{len(video_configs)} successful")
            return success_count > 0
            
        except Exception as e:
            logger.error(f"âŒ Fatal error: {e}")
            return False
        
        finally:
            if self.browser:
                self.browser.close()
                logger.info("ğŸ”’ Browser closed")

def create_sample_files():
    """ìƒ˜í”Œ íŒŒì¼ ìƒì„±"""
    upload_dir = Path("upload_queue")
    upload_dir.mkdir(exist_ok=True)
    
    # í˜„ì¬ ì‹œê°„ + 1ì‹œê°„ í›„ë¡œ ì˜ˆì•½
    schedule_time = datetime.now() + timedelta(hours=1)
    
    samples = {
        "test01_title.txt": "ë‚´ ì²« ë²ˆì§¸ ìë™ ì—…ë¡œë“œ ë¹„ë””ì˜¤",
        "test01_description.txt": """ì•ˆë…•í•˜ì„¸ìš”! ìë™ ì—…ë¡œë“œ í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤.

ğŸ¯ ì£¼ìš” ë‚´ìš©:
- ì™„ì „ ìë™í™”ëœ ì—…ë¡œë“œ
- ì˜ˆì•½ ê²Œì‹œ ê¸°ëŠ¥
- ë©”íƒ€ë°ì´í„° ìë™ ì…ë ¥

#ìë™ì—…ë¡œë“œ #YouTube #í…ŒìŠ¤íŠ¸""",
        "test01_schedule.txt": schedule_time.strftime("%Y-%m-%d %H:%M")
    }
    
    for filename, content in samples.items():
        filepath = upload_dir / filename
        filepath.write_text(content, encoding='utf-8')
    
    print(f"\nâœ… Sample files created in {upload_dir}/")
    print("ğŸ“‹ Next steps:")
    print("1. Add 'test01_video.mp4' to upload_queue/")
    print("2. Optionally add 'test01_thumbnail.jpg'")
    print("3. Run: python youtube_uploader.py")

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="YouTube Auto Uploader")
    parser.add_argument("--headless", action="store_true", help="Run headless")
    parser.add_argument("--privacy", choices=['public', 'unlisted', 'private'], 
                       default='private', help="Privacy setting")
    parser.add_argument("--create-samples", action="store_true", help="Create sample files")
    
    args = parser.parse_args()
    
    if args.create_samples:
        create_sample_files()
    else:
        uploader = YouTubeUploader()
        uploader.settings['privacy'] = args.privacy
        
        if not list(uploader.upload_dir.glob("*_video.mp4")):
            print("âŒ No video files found!")
            print("ğŸ“‹ Use --create-samples first")
        else:
            uploader.run(headless=args.headless)
