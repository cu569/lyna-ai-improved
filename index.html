import os
import sys
import json
import requests
import subprocess
import importlib
import traceback
from datetime import datetime
from typing import Dict, Any, List
import logging
import speech_recognition as sr
import pyttsx3
from googletrans import Translator
import pyaudio
import wave
import threading
import queue
import time

class RimaAI:
    def __init__(self):
        self.name = "ë¦¬ë§ˆ"
        self.version = "1.0.0"
        self.learned_functions = {}
        self.knowledge_base = "rima_knowledge.json"
        self.setup_logging()
        self.load_knowledge()
        
        # ìŒì„± ë²ˆì—­ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        self.setup_voice_translation()
        
    def setup_voice_translation(self):
        """ìŒì„± ë²ˆì—­ ì‹œìŠ¤í…œ ì„¤ì •"""
        try:
            # ìŒì„± ì¸ì‹ ì—”ì§„
            self.recognizer = sr.Recognizer()
            self.microphone = sr.Microphone()
            
            # ìŒì„± í•©ì„± ì—”ì§„  
            self.tts_engine = pyttsx3.init()
            self.tts_engine.setProperty('rate', 150)  # ì†ë„
            self.tts_engine.setProperty('volume', 0.9)  # ë³¼ë¥¨
            
            # ë²ˆì—­ê¸°
            self.translator = Translator()
            
            # ì‹¤ì‹œê°„ ì²˜ë¦¬ë¥¼ ìœ„í•œ í
            self.audio_queue = queue.Queue()
            self.translation_active = False
            
            # ì§€ì› ì–¸ì–´
            self.supported_languages = {
                'korean': 'ko',
                'english': 'en', 
                'japanese': 'ja',
                'chinese': 'zh',
                'spanish': 'es',
                'french': 'fr',
                'german': 'de',
                'russian': 'ru'
            }
            
            # ë§ˆì´í¬ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
            with self.microphone as source:
                self.recognizer.adjust_for_ambient_noise(source)
                
            self.logger.info("ìŒì„± ë²ˆì—­ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ")
            
        except Exception as e:
            self.logger.error(f"ìŒì„± ë²ˆì—­ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            self.install_voice_packages()
    
    def install_voice_packages(self):
        """ìŒì„± ê´€ë ¨ íŒ¨í‚¤ì§€ ìë™ ì„¤ì¹˜"""
        packages = [
            'SpeechRecognition',
            'pyttsx3', 
            'googletrans==4.0.0rc1',
            'pyaudio',
            'wave'
        ]
        
        for package in packages:
            self.install_package(package)
        
        self.logger.info("ìŒì„± íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì™„ë£Œ. í”„ë¡œê·¸ë¨ì„ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”.")
    
    def listen_continuously(self):
        """ì—°ì† ìŒì„± ì¸ì‹"""
        def callback(recognizer, audio):
            try:
                # ìŒì„±ì„ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
                text = recognizer.recognize_google(audio, language='ko-KR')
                self.audio_queue.put(('korean', text))
                self.logger.info(f"ìŒì„± ì¸ì‹: {text}")
            except sr.UnknownValueError:
                pass  # ì¸ì‹ ë¶ˆê°€ëŠ¥í•œ ìŒì„±ì€ ë¬´ì‹œ
            except sr.RequestError as e:
                self.logger.error(f"ìŒì„± ì¸ì‹ ì„œë¹„ìŠ¤ ì˜¤ë¥˜: {e}")
        
        # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì—°ì† ë“£ê¸°
        self.stop_listening = self.recognizer.listen_in_background(
            self.microphone, callback, phrase_time_limit=5
        )
        
        self.logger.info("ì—°ì† ìŒì„± ì¸ì‹ ì‹œì‘")
    
    def recognize_speech(self, language='ko-KR', timeout=10):
        """ë‹¨ë°œì„± ìŒì„± ì¸ì‹"""
        try:
            with self.microphone as source:
                self.logger.info("ìŒì„±ì„ ì…ë ¥í•˜ì„¸ìš”...")
                audio = self.recognizer.listen(source, timeout=timeout, phrase_time_limit=5)
            
            # ì–¸ì–´ë³„ ì¸ì‹
            if language == 'ko-KR':
                text = self.recognizer.recognize_google(audio, language='ko-KR')
            elif language == 'en-US':
                text = self.recognizer.recognize_google(audio, language='en-US')
            elif language == 'ja-JP':
                text = self.recognizer.recognize_google(audio, language='ja-JP')
            else:
                text = self.recognizer.recognize_google(audio, language=language)
            
            self.logger.info(f"ì¸ì‹ëœ í…ìŠ¤íŠ¸: {text}")
            return text
            
        except sr.UnknownValueError:
            return "ìŒì„±ì„ ì¸ì‹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        except sr.RequestError as e:
            return f"ìŒì„± ì¸ì‹ ì„œë¹„ìŠ¤ ì˜¤ë¥˜: {e}"
        except Exception as e:
            return f"ìŒì„± ì¸ì‹ ì˜¤ë¥˜: {e}"
    
    def translate_text(self, text, target_lang='en', source_lang='auto'):
        """í…ìŠ¤íŠ¸ ë²ˆì—­"""
        try:
            # ì–¸ì–´ ì½”ë“œ ë³€í™˜
            if target_lang in self.supported_languages:
                target_lang = self.supported_languages[target_lang]
            
            # ë²ˆì—­ ì‹¤í–‰
            result = self.translator.translate(text, src=source_lang, dest=target_lang)
            
            translation_info = {
                'original': text,
                'translated': result.text,
                'source_lang': result.src,
                'target_lang': target_lang,
                'confidence': getattr(result, 'confidence', 'N/A')
            }
            
            self.logger.info(f"ë²ˆì—­ ì™„ë£Œ: {text} -> {result.text}")
            return translation_info
            
        except Exception as e:
            self.logger.error(f"ë²ˆì—­ ì˜¤ë¥˜: {e}")
            return {'error': str(e)}
    
    def speak_text(self, text, language='ko'):
        """í…ìŠ¤íŠ¸ë¥¼ ìŒì„±ìœ¼ë¡œ ì¶œë ¥"""
        try:
            # ì–¸ì–´ë³„ ìŒì„± ì„¤ì •
            voices = self.tts_engine.getProperty('voices')
            
            if language == 'ko':
                # í•œêµ­ì–´ ìŒì„± ì°¾ê¸°
                for voice in voices:
                    if 'korean' in voice.name.lower() or 'ko' in voice.id.lower():
                        self.tts_engine.setProperty('voice', voice.id)
                        break
            elif language == 'en':
                # ì˜ì–´ ìŒì„± ì°¾ê¸°
                for voice in voices:
                    if 'english' in voice.name.lower() or 'en' in voice.id.lower():
                        self.tts_engine.setProperty('voice', voice.id)
                        break
            
            # ìŒì„± ì¶œë ¥
            self.tts_engine.say(text)
            self.tts_engine.runAndWait()
            
            self.logger.info(f"ìŒì„± ì¶œë ¥: {text}")
            
        except Exception as e:
            self.logger.error(f"ìŒì„± ì¶œë ¥ ì˜¤ë¥˜: {e}")
    
    def real_time_translation(self, source_lang='ko', target_lang='en'):
        """ì‹¤ì‹œê°„ ìŒì„± ë²ˆì—­"""
        self.translation_active = True
        self.logger.info(f"ì‹¤ì‹œê°„ ë²ˆì—­ ì‹œì‘: {source_lang} -> {target_lang}")
        
        # ì—°ì† ìŒì„± ì¸ì‹ ì‹œì‘
        self.listen_continuously()
        
        print("ì‹¤ì‹œê°„ ë²ˆì—­ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. 'q'ë¥¼ ì…ë ¥í•˜ë©´ ì¢…ë£Œí•©ë‹ˆë‹¤.")
        
        try:
            while self.translation_active:
                # íì—ì„œ ìŒì„± ë°ì´í„° í™•ì¸
                if not self.audio_queue.empty():
                    lang, text = self.audio_queue.get()
                    
                    if text:
                        print(f"[{lang}] ì›ë¬¸: {text}")
                        
                        # ë²ˆì—­
                        translation = self.translate_text(text, target_lang, source_lang)
                        if 'error' not in translation:
                            translated_text = translation['translated']
                            print(f"[{target_lang}] ë²ˆì—­: {translated_text}")
                            
                            # ë²ˆì—­ëœ í…ìŠ¤íŠ¸ ìŒì„± ì¶œë ¥
                            self.speak_text(translated_text, target_lang)
                
                # ì¢…ë£Œ í™•ì¸
                time.sleep(0.1)
                
        except KeyboardInterrupt:
            pass
        finally:
            self.stop_real_time_translation()
    
    def stop_real_time_translation(self):
        """ì‹¤ì‹œê°„ ë²ˆì—­ ì¤‘ì§€"""
        self.translation_active = False
        if hasattr(self, 'stop_listening'):
            self.stop_listening()
        self.logger.info("ì‹¤ì‹œê°„ ë²ˆì—­ ì¤‘ì§€")
    
    def voice_translation_demo(self):
        """ìŒì„± ë²ˆì—­ ë°ëª¨"""
        print("\n=== ë¦¬ë§ˆ ìŒì„± ë²ˆì—­ ì‹œìŠ¤í…œ ===")
        print("1. ë‹¨ë°œì„± ë²ˆì—­")
        print("2. ì‹¤ì‹œê°„ ë²ˆì—­")
        print("3. í…ìŠ¤íŠ¸ ë²ˆì—­")
        print("4. ì§€ì› ì–¸ì–´ í™•ì¸")
        
        choice = input("ì„ íƒí•˜ì„¸ìš” (1-4): ")
        
        if choice == '1':
            # ë‹¨ë°œì„± ë²ˆì—­
            print("ìŒì„±ì„ ì…ë ¥í•˜ì„¸ìš”...")
            speech = self.recognize_speech()
            if speech:
                target = input("ë²ˆì—­í•  ì–¸ì–´ (en/ja/zh/es/fr/de/ru): ")
                result = self.translate_text(speech, target)
                if 'error' not in result:
                    print(f"ë²ˆì—­ ê²°ê³¼: {result['translated']}")
                    self.speak_text(result['translated'], target)
        
        elif choice == '2':
            # ì‹¤ì‹œê°„ ë²ˆì—­
            source = input("ì›ë³¸ ì–¸ì–´ (ko/en/ja): ")
            target = input("ëª©í‘œ ì–¸ì–´ (ko/en/ja): ")
            self.real_time_translation(source, target)
        
        elif choice == '3':
            # í…ìŠ¤íŠ¸ ë²ˆì—­
            text = input("ë²ˆì—­í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”: ")
            target = input("ë²ˆì—­í•  ì–¸ì–´ (en/ja/zh/es/fr/de/ru): ")
            result = self.translate_text(text, target)
            if 'error' not in result:
                print(f"ë²ˆì—­ ê²°ê³¼: {result['translated']}")
                self.speak_text(result['translated'], target)
        
        elif choice == '4':
            # ì§€ì› ì–¸ì–´
            print("ì§€ì› ì–¸ì–´:")
            for lang, code in self.supported_languages.items():
                print(f"  {lang}: {code}")
                
        return "ìŒì„± ë²ˆì—­ ë°ëª¨ ì™„ë£Œ"
        
    def setup_logging(self):
        """ë¡œê¹… ì„¤ì •"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - ë¦¬ë§ˆ - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
        
    def load_knowledge(self):
        """ê¸°ì¡´ í•™ìŠµ ë‚´ìš© ë¡œë“œ"""
        try:
            if os.path.exists(self.knowledge_base):
                with open(self.knowledge_base, 'r', encoding='utf-8') as f:
                    self.learned_functions = json.load(f)
                self.logger.info(f"ê¸°ì¡´ í•™ìŠµ ë‚´ìš© ë¡œë“œ ì™„ë£Œ: {len(self.learned_functions)}ê°œ ê¸°ëŠ¥")
            else:
                self.learned_functions = {}
                self.logger.info("ìƒˆë¡œìš´ ì§€ì‹ ë² ì´ìŠ¤ ìƒì„±")
        except Exception as e:
            self.logger.error(f"ì§€ì‹ ë² ì´ìŠ¤ ë¡œë“œ ì‹¤íŒ¨: {e}")
            self.learned_functions = {}
    
    def save_knowledge(self):
        """í•™ìŠµ ë‚´ìš© ì €ì¥"""
        try:
            with open(self.knowledge_base, 'w', encoding='utf-8') as f:
                json.dump(self.learned_functions, f, ensure_ascii=False, indent=2)
            self.logger.info("í•™ìŠµ ë‚´ìš© ì €ì¥ ì™„ë£Œ")
        except Exception as e:
            self.logger.error(f"í•™ìŠµ ë‚´ìš© ì €ì¥ ì‹¤íŒ¨: {e}")
    
    def install_package(self, package_name: str) -> bool:
        """í•„ìš”í•œ íŒ¨í‚¤ì§€ ìë™ ì„¤ì¹˜"""
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", package_name])
            self.logger.info(f"íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì™„ë£Œ: {package_name}")
            return True
        except subprocess.CalledProcessError as e:
            self.logger.error(f"íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì‹¤íŒ¨: {package_name} - {e}")
            return False
    
    def search_solution(self, problem: str) -> str:
        """ë¬¸ì œ í•´ê²°ì±… ê²€ìƒ‰"""
        try:
            # ê°„ë‹¨í•œ ê²€ìƒ‰ ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œë¡œëŠ” ì›¹ ê²€ìƒ‰ API ì‚¬ìš©)
            search_query = f"python how to {problem}"
            self.logger.info(f"í•´ê²°ì±… ê²€ìƒ‰ ì¤‘: {search_query}")
            
            # ê¸°ë³¸ í•´ê²°ì±… í…œí”Œë¦¿
            solutions = {
                "file": """
def handle_file_operation(operation, filename, content=None):
    if operation == 'read':
        with open(filename, 'r', encoding='utf-8') as f:
            return f.read()
    elif operation == 'write':
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(content)
        return f"íŒŒì¼ ì €ì¥ ì™„ë£Œ: {filename}"
""",
                "web": """
import requests
def web_request(url, method='GET', data=None):
    try:
        if method == 'GET':
            response = requests.get(url)
        elif method == 'POST':
            response = requests.post(url, json=data)
        return response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text
    except Exception as e:
        return f"ì›¹ ìš”ì²­ ì‹¤íŒ¨: {e}"
""",
                "youtube": """
from selenium import webdriver
from selenium.webdriver.common.by import By
import time

def youtube_click_upload():
    driver = webdriver.Chrome()
    try:
        driver.get("https://studio.youtube.com")
        time.sleep(3)
        # ê²Œì‹œ ë²„íŠ¼ í´ë¦­
        publish_btn = driver.find_element(By.ID, "publish-button")
        publish_btn.click()
        return "YouTube ì—…ë¡œë“œ ì™„ë£Œ"
    finally:
        driver.quit()
""",
                "translate": """
def translate_text(text, target_lang='en'):
    # ì‹¤ì œë¡œëŠ” Google Translate API ì‚¬ìš©
    return f"ë²ˆì—­ëœ í…ìŠ¤íŠ¸: {text} -> {target_lang}"
""",
                "default": """
def handle_task(task_name, *args, **kwargs):
    return f"'{task_name}' ì‘ì—…ì„ ì²˜ë¦¬í–ˆìŠµë‹ˆë‹¤. ì¸ìˆ˜: {args}, í‚¤ì›Œë“œ: {kwargs}"
"""
            }
            
            # í‚¤ì›Œë“œ ë§¤ì¹­ìœ¼ë¡œ ì ì ˆí•œ ì†”ë£¨ì…˜ ë°˜í™˜
            for key, solution in solutions.items():
                if key in problem.lower():
                    return solution
            
            return solutions["default"]
            
        except Exception as e:
            self.logger.error(f"í•´ê²°ì±… ê²€ìƒ‰ ì‹¤íŒ¨: {e}")
            return None
    
    def learn_new_function(self, task_name: str, task_description: str):
        """ìƒˆë¡œìš´ ê¸°ëŠ¥ í•™ìŠµ"""
        self.logger.info(f"ìƒˆë¡œìš´ ê¸°ëŠ¥ í•™ìŠµ ì‹œì‘: {task_name}")
        
        try:
            # 1. í•´ê²°ì±… ê²€ìƒ‰
            solution_code = self.search_solution(task_description)
            if not solution_code:
                return False
            
            # 2. ë™ì  ì½”ë“œ ìƒì„± ë° ì‹¤í–‰
            exec_globals = {}
            exec(solution_code, exec_globals)
            
            # 3. í•™ìŠµ ë‚´ìš© ì €ì¥
            self.learned_functions[task_name] = {
                "description": task_description,
                "code": solution_code,
                "learned_at": datetime.now().isoformat(),
                "usage_count": 0
            }
            
            self.save_knowledge()
            self.logger.info(f"ìƒˆë¡œìš´ ê¸°ëŠ¥ í•™ìŠµ ì™„ë£Œ: {task_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"ê¸°ëŠ¥ í•™ìŠµ ì‹¤íŒ¨: {task_name} - {e}")
            return False
    
    def execute_task(self, task_name: str, *args, **kwargs):
        """ì‘ì—… ì‹¤í–‰"""
        try:
            # ê¸°ì¡´ í•™ìŠµëœ ê¸°ëŠ¥ í™•ì¸
            if task_name in self.learned_functions:
                self.learned_functions[task_name]["usage_count"] += 1
                code = self.learned_functions[task_name]["code"]
                
                # ë™ì  ì‹¤í–‰
                exec_globals = {}
                exec(code, exec_globals)
                
                # í•¨ìˆ˜ ì°¾ê¸° ë° ì‹¤í–‰
                for func_name, func_obj in exec_globals.items():
                    if callable(func_obj) and not func_name.startswith('__'):
                        result = func_obj(*args, **kwargs)
                        self.logger.info(f"ì‘ì—… ì‹¤í–‰ ì™„ë£Œ: {task_name}")
                        return result
            
            else:
                # ìƒˆë¡œìš´ ê¸°ëŠ¥ í•™ìŠµ
                self.logger.info(f"ì•Œ ìˆ˜ ì—†ëŠ” ì‘ì—…: {task_name}. í•™ìŠµì„ ì‹œì‘í•©ë‹ˆë‹¤.")
                if self.learn_new_function(task_name, f"{task_name} ì‘ì—… ìˆ˜í–‰"):
                    return self.execute_task(task_name, *args, **kwargs)
                else:
                    return f"ì‘ì—… '{task_name}' í•™ìŠµì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
                    
        except Exception as e:
            self.logger.error(f"ì‘ì—… ì‹¤í–‰ ì‹¤íŒ¨: {task_name} - {e}")
            return f"ì‘ì—… ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}"
    
    def get_capabilities(self):
        """í˜„ì¬ ê°€ëŠ¥í•œ ê¸°ëŠ¥ ëª©ë¡"""
        base_capabilities = [
            "íŒŒì¼ ì½ê¸°/ì“°ê¸°",
            "ì›¹ ìš”ì²­",
            "YouTube ì—…ë¡œë“œ í´ë¦­",
            "í…ìŠ¤íŠ¸ ë²ˆì—­",
            "ë°ì´í„° ì²˜ë¦¬"
        ]
        
        learned_capabilities = list(self.learned_functions.keys())
        all_capabilities = base_capabilities + learned_capabilities
        
        return {
            "ê¸°ë³¸_ê¸°ëŠ¥": base_capabilities,
            "í•™ìŠµëœ_ê¸°ëŠ¥": learned_capabilities,
            "ì „ì²´_ê¸°ëŠ¥_ìˆ˜": len(all_capabilities)
        }
    
    def chat(self, message: str):
        """ë¦¬ë§ˆì™€ ëŒ€í™”"""
        self.logger.info(f"ì‚¬ìš©ì ë©”ì‹œì§€: {message}")
        
        if "ì•ˆë…•" in message or "hello" in message.lower():
            return f"ì•ˆë…•í•˜ì„¸ìš”! ì €ëŠ” {self.name}ì…ë‹ˆë‹¤. ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?"
        
        elif "ê¸°ëŠ¥" in message or "ë­í• ìˆ˜ìˆì–´" in message:
            capabilities = self.get_capabilities()
            return f"í˜„ì¬ ê°€ëŠ¥í•œ ê¸°ëŠ¥:\n{json.dumps(capabilities, ensure_ascii=False, indent=2)}"
        
        elif "í•™ìŠµ" in message:
            return "ìƒˆë¡œìš´ ì‘ì—…ì„ ìš”ì²­í•˜ì‹œë©´ ìë™ìœ¼ë¡œ í•™ìŠµí•´ì„œ ì²˜ë¦¬í•´ë“œë¦½ë‹ˆë‹¤!"
        
        elif "youtube" in message.lower() or "ìœ íŠœë¸Œ" in message:
            return self.execute_task("youtube_upload")
        
        elif "ë²ˆì—­" in message or "translate" in message.lower():
            return self.voice_translation_demo()
        
        elif "ìŒì„±" in message or "voice" in message.lower():
            return self.voice_translation_demo()
        
        elif "ì‹¤ì‹œê°„" in message or "realtime" in message.lower():
            return self.real_time_translation()
        
        elif "ë“£ê¸°" in message or "listen" in message.lower():
            speech = self.recognize_speech()
            return f"ì¸ì‹ëœ ìŒì„±: {speech}"
        
        elif "íŒŒì¼" in message:
            return self.execute_task("file_operation", "read", "example.txt")
        
        else:
            # ì¼ë°˜ì ì¸ ì‘ì—… ì²˜ë¦¬
            return self.execute_task("general_task", message)

# ë¦¬ë§ˆ ì‹œìŠ¤í…œ ì‹¤í–‰
def main():
    rima = RimaAI()
    
    print("=" * 50)
    print(f"ğŸ¤– {rima.name} v{rima.version} ì‹œì‘!")
    print("ğŸ¤ ìŒì„± ë²ˆì—­ ì‹œìŠ¤í…œ íƒ‘ì¬!")
    print("ğŸŒ ì‹¤ì‹œê°„ ë‹¤êµ­ì–´ ë²ˆì—­ ì§€ì›!")
    print("ğŸ“ ëª…ë ¹ì–´: 'ë²ˆì—­', 'ìŒì„±', 'ì‹¤ì‹œê°„', 'ë“£ê¸°'")
    print("=" * 50)
    
    while True:
        try:
            user_input = input("\nì‚¬ìš©ì: ")
            
            if user_input.lower() in ['quit', 'exit', 'ì¢…ë£Œ']:
                print("ë¦¬ë§ˆ: ì•ˆë…•íˆ ê°€ì„¸ìš”!")
                break
            
            response = rima.chat(user_input)
            print(f"ë¦¬ë§ˆ: {response}")
            
        except KeyboardInterrupt:
            print("\në¦¬ë§ˆ: ì•ˆë…•íˆ ê°€ì„¸ìš”!")
            break
        except Exception as e:
            print(f"ë¦¬ë§ˆ: ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤ - {e}")

if __name__ == "__main__":
    main()
