# ì‹¤ì œ YouTube ìë™ ì—…ë¡œë“œ ì‹œìŠ¤í…œ (ì§„ì§œ ì‘ë™)
# API ì—†ì´ ë¸Œë¼ìš°ì € ìë™í™”ë¡œ ì‹¤ì œ ì—…ë¡œë“œ

import os
import time
import json
import shutil
from datetime import datetime
from pathlib import Path
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class RealYouTubeUploader:
    def __init__(self):
        self.watch_folder = Path("upload_videos")
        self.archive_folder = Path("uploaded_videos")
        self.logs_folder = Path("logs")
        self.processed_file = Path("processed_files.json")
        self.chrome_profile = None
        self.setup_folders()
        
    def setup_folders(self):
        """í•„ìš”í•œ í´ë” ìƒì„±"""
        self.watch_folder.mkdir(exist_ok=True)
        self.archive_folder.mkdir(exist_ok=True)
        self.logs_folder.mkdir(exist_ok=True)
        
    def log(self, message, level="INFO"):
        """ë¡œê·¸ ê¸°ë¡"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"
        print(log_entry)
        
        log_file = self.logs_folder / "uploader.log"
        with open(log_file, "a", encoding="utf-8") as f:
            f.write(log_entry + "\n")
    
    def setup_chrome_driver(self):
        """Chrome ë“œë¼ì´ë²„ ì„¤ì • (ì‹¤ì œ ì„¸ì…˜ ìœ ì§€)"""
        options = Options()
        
        # ì¤‘ìš”: ì‚¬ìš©ì í”„ë¡œí•„ ê²½ë¡œ ì„¤ì • (ë¡œê·¸ì¸ ì„¸ì…˜ ìœ ì§€)
        if self.chrome_profile:
            options.add_argument(f"--user-data-dir={self.chrome_profile}")
        
        # í—¤ë“œë¦¬ìŠ¤ ëª¨ë“œ (í•„ìš”ì‹œ ì£¼ì„ í•´ì œ)
        # options.add_argument("--headless")
        
        # ì•ˆì •ì„± í–¥ìƒ ì˜µì…˜
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        
        # ìë™ìœ¼ë¡œ ChromeDriver ë‹¤ìš´ë¡œë“œ
        service = Service(ChromeDriverManager().install())
        driver = webdriver.Chrome(service=service, options=options)
        
        # ìë™í™” ê°ì§€ ìš°íšŒ
        driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        
        return driver
    
    def set_chrome_profile(self, profile_path):
        """Chrome í”„ë¡œí•„ ê²½ë¡œ ì„¤ì •"""
        self.chrome_profile = profile_path
        self.log(f"Chrome í”„ë¡œí•„ ì„¤ì •: {profile_path}")
    
    def wait_for_login(self, driver):
        """ë¡œê·¸ì¸ ëŒ€ê¸°"""
        self.log("YouTube Studio ì ‘ì† ì¤‘...")
        driver.get("https://studio.youtube.com/")
        
        # ë¡œê·¸ì¸ í™•ì¸ ëŒ€ê¸°
        try:
            # ë¡œê·¸ì¸ëœ ìƒíƒœë©´ ì±„ë„ ì„ íƒ ë˜ëŠ” ëŒ€ì‹œë³´ë“œê°€ ë³´ì„
            WebDriverWait(driver, 10).until(
                EC.any_of(
                    EC.presence_of_element_located((By.ID, "create-icon")),
                    EC.presence_of_element_located((By.XPATH, "//ytcp-button[@id='create-icon']"))
                )
            )
            self.log("ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸ë¨")
            return True
        except:
            self.log("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.")
            input("ë¡œê·¸ì¸ ì™„ë£Œ í›„ ì—”í„°ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”: ")
            return True
    
    def upload_video(self, video_path, title, description="", is_public=True):
        """ì‹¤ì œ YouTube ì—…ë¡œë“œ ì‹¤í–‰"""
        driver = None
        try:
            self.log(f"ì—…ë¡œë“œ ì‹œì‘: {video_path.name}")
            
            # Chrome ë“œë¼ì´ë²„ ì„¤ì •
            driver = self.setup_chrome_driver()
            wait = WebDriverWait(driver, 30)
            
            # ë¡œê·¸ì¸ í™•ì¸
            if not self.wait_for_login(driver):
                return False
            
            # 1. ë§Œë“¤ê¸° ë²„íŠ¼ í´ë¦­
            self.log("ì—…ë¡œë“œ ë²„íŠ¼ í´ë¦­...")
            create_button = wait.until(
                EC.element_to_be_clickable((By.XPATH, "//ytcp-button[@id='create-icon']"))
            )
            create_button.click()
            
            # 2. ë™ì˜ìƒ ì—…ë¡œë“œ ì„ íƒ
            upload_option = wait.until(
                EC.element_to_be_clickable((By.XPATH, "//tp-yt-paper-item[@test-id='upload-video']"))
            )
            upload_option.click()
            
            # 3. íŒŒì¼ ì„ íƒ
            self.log("íŒŒì¼ ì—…ë¡œë“œ ì¤‘...")
            file_input = wait.until(
                EC.presence_of_element_located((By.XPATH, "//input[@type='file']"))
            )
            file_input.send_keys(str(video_path.absolute()))
            
            # íŒŒì¼ ì—…ë¡œë“œ ëŒ€ê¸°
            time.sleep(5)
            
            # 4. ì œëª© ì…ë ¥
            self.log("ì œëª© ì…ë ¥ ì¤‘...")
            title_input = wait.until(
                EC.element_to_be_clickable((By.XPATH, "//div[@id='textbox' and @aria-label='ì œëª©ì„ ì¶”ê°€í•˜ì„¸ìš”']"))
            )
            title_input.clear()
            title_input.send_keys(title)
            
            # 5. ì„¤ëª… ì…ë ¥ (ì„ íƒì‚¬í•­)
            if description:
                self.log("ì„¤ëª… ì…ë ¥ ì¤‘...")
                try:
                    desc_input = driver.find_element(By.XPATH, "//div[@id='textbox' and @aria-label='ì‹œì²­ìì—ê²Œ ì˜ìƒì„ ì„¤ëª…í•˜ì„¸ìš”']")
                    desc_input.clear()
                    desc_input.send_keys(description)
                except:
                    self.log("ì„¤ëª… ì…ë ¥ ê±´ë„ˆëœ€")
            
            # 6. ë‹¤ìŒ ë‹¨ê³„ë“¤ ì§„í–‰
            self.log("ì—…ë¡œë“œ ì„¤ì • ì§„í–‰...")
            for step in range(3):
                try:
                    next_button = wait.until(
                        EC.element_to_be_clickable((By.XPATH, "//ytcp-button[@id='next-button']"))
                    )
                    next_button.click()
                    time.sleep(2)
                    self.log(f"ë‹¨ê³„ {step+1}/3 ì™„ë£Œ")
                except:
                    self.log(f"ë‹¨ê³„ {step+1} ê±´ë„ˆëœ€")
            
            # 7. ê³µê°œ ì„¤ì •
            if is_public:
                self.log("ê³µê°œ ì„¤ì • ì ìš©...")
                try:
                    public_radio = wait.until(
                        EC.element_to_be_clickable((By.XPATH, "//tp-yt-paper-radio-button[@name='PUBLIC']"))
                    )
                    public_radio.click()
                except:
                    self.log("ê³µê°œ ì„¤ì • ì‹¤íŒ¨ (ê¸°ë³¸ê°’ ìœ ì§€)")
            
            # 8. ê²Œì‹œí•˜ê¸°
            self.log("ê²Œì‹œ ì¤‘...")
            publish_button = wait.until(
                EC.element_to_be_clickable((By.XPATH, "//ytcp-button[@id='done-button']"))
            )
            publish_button.click()
            
            # 9. ì—…ë¡œë“œ ì™„ë£Œ ëŒ€ê¸°
            self.log("ì—…ë¡œë“œ ì™„ë£Œ ëŒ€ê¸°...")
            time.sleep(15)
            
            # 10. ì˜ìƒ ë§í¬ ì¶”ì¶œ ì‹œë„
            try:
                video_link = wait.until(
                    EC.presence_of_element_located((By.XPATH, "//a[contains(@href, '/watch?v=')]"))
                )
                video_url = video_link.get_attribute('href')
                self.log(f"ì—…ë¡œë“œ ì„±ê³µ: {video_url}")
                return video_url
            except:
                self.log("ì—…ë¡œë“œ ì™„ë£Œ (ë§í¬ ì¶”ì¶œ ì‹¤íŒ¨)")
                return True
                
        except Exception as e:
            self.log(f"ì—…ë¡œë“œ ì‹¤íŒ¨: {str(e)}", "ERROR")
            return False
        finally:
            if driver:
                driver.quit()
    
    def generate_metadata(self, video_path):
        """ì˜ìƒ ë©”íƒ€ë°ì´í„° ìƒì„±"""
        # íŒŒì¼ëª…ì„ ê¸°ë°˜ìœ¼ë¡œ ì œëª© ìƒì„±
        title = video_path.stem.replace('_', ' ').replace('-', ' ').title()
        
        # ì„¤ëª… ìƒì„±
        description = f"""
{title}

ğŸ“¹ ì—…ë¡œë“œ ì •ë³´:
- íŒŒì¼ëª…: {video_path.name}
- ì—…ë¡œë“œ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- ìë™ ì—…ë¡œë“œ: Real YouTube Uploader

#ìë™ì—…ë¡œë“œ #YouTube #ì˜ìƒ
        """.strip()
        
        return title, description
    
    def archive_video(self, video_path):
        """ì—…ë¡œë“œ ì™„ë£Œëœ ì˜ìƒ ë³´ê´€"""
        try:
            archive_path = self.archive_folder / video_path.name
            shutil.move(str(video_path), str(archive_path))
            self.log(f"ì˜ìƒ ë³´ê´€: {archive_path}")
            return True
        except Exception as e:
            self.log(f"ì˜ìƒ ë³´ê´€ ì‹¤íŒ¨: {str(e)}", "ERROR")
            return False
    
    def save_processed_record(self, video_name, result):
        """ì²˜ë¦¬ ê¸°ë¡ ì €ì¥"""
        try:
            if self.processed_file.exists():
                with open(self.processed_file, 'r', encoding='utf-8') as f:
                    records = json.load(f)
            else:
                records = {}
            
            records[video_name] = {
                'timestamp': datetime.now().isoformat(),
                'result': result,
                'url': result if isinstance(result, str) else None
            }
            
            with open(self.processed_file, 'w', encoding='utf-8') as f:
                json.dump(records, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            self.log(f"ê¸°ë¡ ì €ì¥ ì‹¤íŒ¨: {str(e)}", "ERROR")
    
    def process_single_video(self, video_path):
        """ë‹¨ì¼ ì˜ìƒ ì²˜ë¦¬"""
        try:
            # ë©”íƒ€ë°ì´í„° ìƒì„±
            title, description = self.generate_metadata(video_path)
            
            # ì—…ë¡œë“œ ì‹¤í–‰
            result = self.upload_video(video_path, title, description)
            
            if result:
                # ì„±ê³µ ì‹œ ë³´ê´€
                self.archive_video(video_path)
                self.save_processed_record(video_path.name, result)
                self.log(f"âœ… ì²˜ë¦¬ ì™„ë£Œ: {video_path.name}")
                return True
            else:
                self.log(f"âŒ ì²˜ë¦¬ ì‹¤íŒ¨: {video_path.name}")
                return False
                
        except Exception as e:
            self.log(f"ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}", "ERROR")
            return False
    
    def scan_and_process(self):
        """í´ë” ìŠ¤ìº” í›„ ì²˜ë¦¬"""
        video_extensions = ['.mp4', '.mov', '.avi', '.mkv']
        
        for video_file in self.watch_folder.iterdir():
            if (video_file.is_file() and 
                video_file.suffix.lower() in video_extensions):
                
                self.log(f"ìƒˆ ì˜ìƒ ë°œê²¬: {video_file.name}")
                self.process_single_video(video_file)
    
    def run_continuous(self):
        """ì§€ì†ì  í´ë” ê°ì‹œ"""
        self.log("ì§€ì†ì  í´ë” ê°ì‹œ ì‹œì‘...")
        
        while True:
            try:
                self.scan_and_process()
                time.sleep(60)  # 60ì´ˆë§ˆë‹¤ í™•ì¸
            except KeyboardInterrupt:
                self.log("ì‚¬ìš©ì ì¤‘ë‹¨")
                break
            except Exception as e:
                self.log(f"ê°ì‹œ ì¤‘ ì˜¤ë¥˜: {str(e)}", "ERROR")
                time.sleep(30)

class RealTimeWatcher(FileSystemEventHandler):
    """ì‹¤ì‹œê°„ íŒŒì¼ ê°ì‹œ"""
    def __init__(self, uploader):
        self.uploader = uploader
    
    def on_created(self, event):
        if not event.is_directory:
            file_path = Path(event.src_path)
            if file_path.suffix.lower() in ['.mp4', '.mov', '.avi', '.mkv']:
                self.uploader.log(f"ì‹¤ì‹œê°„ ê°ì§€: {file_path.name}")
                time.sleep(5)  # íŒŒì¼ ë³µì‚¬ ì™„ë£Œ ëŒ€ê¸°
                self.uploader.process_single_video(file_path)

def main():
    print("ğŸ¬ ì‹¤ì œ YouTube ìë™ ì—…ë¡œë“œ ì‹œìŠ¤í…œ")
    print("=" * 50)
    
    # ì—…ë¡œë” ì´ˆê¸°í™”
    uploader = RealYouTubeUploader()
    
    # Chrome í”„ë¡œí•„ ì„¤ì • (ì„ íƒì‚¬í•­)
    profile_path = input("Chrome í”„ë¡œí•„ ê²½ë¡œ (ì—”í„°ë¡œ ê¸°ë³¸ê°’): ").strip()
    if profile_path:
        uploader.set_chrome_profile(profile_path)
    
    # ì‹¤í–‰ ëª¨ë“œ ì„ íƒ
    mode = input("""
ì‹¤í–‰ ëª¨ë“œ:
1. ë‹¨ë°œ ì²˜ë¦¬ (í˜„ì¬ íŒŒì¼ë“¤ë§Œ)
2. ì§€ì†ì  ê°ì‹œ (60ì´ˆ ê°„ê²©)
3. ì‹¤ì‹œê°„ ê°ì‹œ (ì¦‰ì‹œ ì²˜ë¦¬)

ì„ íƒ (1-3): """).strip()
    
    if mode == "1":
        print("ğŸ“‚ ë‹¨ë°œ ì²˜ë¦¬ ëª¨ë“œ")
        uploader.scan_and_process()
        
    elif mode == "2":
        print("ğŸ”„ ì§€ì†ì  ê°ì‹œ ëª¨ë“œ")
        uploader.run_continuous()
        
    elif mode == "3":
        print("âš¡ ì‹¤ì‹œê°„ ê°ì‹œ ëª¨ë“œ")
        observer = Observer()
        observer.schedule(
            RealTimeWatcher(uploader), 
            str(uploader.watch_folder), 
            recursive=False
        )
        observer.start()
        
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            observer.stop()
        observer.join()
        
    else:
        print("âŒ ì˜ëª»ëœ ì„ íƒ")

if __name__ == "__main__":
    main()

# ì„¤ì¹˜ ë° ì‹¤í–‰ ê°€ì´ë“œ
"""
ğŸ”§ ì„¤ì¹˜ ë°©ë²•:

1. í•„ìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜:
   pip install selenium webdriver-manager watchdog

2. Chrome ë¸Œë¼ìš°ì € ì„¤ì¹˜ (ìµœì‹  ë²„ì „)

3. í´ë” êµ¬ì¡° ìƒì„±:
   mkdir upload_videos uploaded_videos logs

4. ì‹¤í–‰:
   python real_youtube_uploader.py

ğŸ“ ì‚¬ìš© ë°©ë²•:

1. upload_videos í´ë”ì— mp4 íŒŒì¼ ë„£ê¸°
2. í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì‹œ ëª¨ë“œ ì„ íƒ
3. ì²« ì‹¤í–‰ì‹œ YouTube ë¡œê·¸ì¸ (í•œ ë²ˆë§Œ)
4. ìë™ ì—…ë¡œë“œ ì§„í–‰ í™•ì¸
5. logs í´ë”ì—ì„œ ê²°ê³¼ í™•ì¸

ğŸ” Chrome í”„ë¡œí•„ ì„¤ì • (ì¤‘ìš”):

1. Chrome ì£¼ì†Œì°½ì— chrome://version ì…ë ¥
2. í”„ë¡œí•„ ê²½ë¡œ ë³µì‚¬
3. í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì‹œ ê²½ë¡œ ì…ë ¥
4. ë¡œê·¸ì¸ ì„¸ì…˜ ìë™ ìœ ì§€

âš ï¸ ì£¼ì˜ì‚¬í•­:

- ì²« ì‹¤í–‰ ì‹œ ìˆ˜ë™ ë¡œê·¸ì¸ í•„ìš”
- ëŒ€ìš©ëŸ‰ íŒŒì¼ì€ ì—…ë¡œë“œ ì‹œê°„ ì˜¤ë˜ ê±¸ë¦¼
- YouTube UI ë³€ê²½ ì‹œ ì…€ë ‰í„° ìˆ˜ì • í•„ìš”
- í—¤ë“œë¦¬ìŠ¤ ëª¨ë“œëŠ” ë””ë²„ê¹… í›„ ì‚¬ìš© ê¶Œì¥
"""
