# 실제 YouTube 자동 업로드 시스템 (진짜 작동)
# API 없이 브라우저 자동화로 실제 업로드

import os
import time
import json
import shutil
from datetime import datetime
from pathlib import Path
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class RealYouTubeUploader:
    def __init__(self):
        self.watch_folder = Path("upload_videos")
        self.archive_folder = Path("uploaded_videos")
        self.logs_folder = Path("logs")
        self.processed_file = Path("processed_files.json")
        self.chrome_profile = None
        self.setup_folders()
        
    def setup_folders(self):
        """필요한 폴더 생성"""
        self.watch_folder.mkdir(exist_ok=True)
        self.archive_folder.mkdir(exist_ok=True)
        self.logs_folder.mkdir(exist_ok=True)
        
    def log(self, message, level="INFO"):
        """로그 기록"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"
        print(log_entry)
        
        log_file = self.logs_folder / "uploader.log"
        with open(log_file, "a", encoding="utf-8") as f:
            f.write(log_entry + "\n")
    
    def setup_chrome_driver(self):
        """Chrome 드라이버 설정 (실제 세션 유지)"""
        options = Options()
        
        # 중요: 사용자 프로필 경로 설정 (로그인 세션 유지)
        if self.chrome_profile:
            options.add_argument(f"--user-data-dir={self.chrome_profile}")
        
        # 헤드리스 모드 (필요시 주석 해제)
        # options.add_argument("--headless")
        
        # 안정성 향상 옵션
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        
        # 자동으로 ChromeDriver 다운로드
        service = Service(ChromeDriverManager().install())
        driver = webdriver.Chrome(service=service, options=options)
        
        # 자동화 감지 우회
        driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        
        return driver
    
    def set_chrome_profile(self, profile_path):
        """Chrome 프로필 경로 설정"""
        self.chrome_profile = profile_path
        self.log(f"Chrome 프로필 설정: {profile_path}")
    
    def wait_for_login(self, driver):
        """로그인 대기"""
        self.log("YouTube Studio 접속 중...")
        driver.get("https://studio.youtube.com/")
        
        # 로그인 확인 대기
        try:
            # 로그인된 상태면 채널 선택 또는 대시보드가 보임
            WebDriverWait(driver, 10).until(
                EC.any_of(
                    EC.presence_of_element_located((By.ID, "create-icon")),
                    EC.presence_of_element_located((By.XPATH, "//ytcp-button[@id='create-icon']"))
                )
            )
            self.log("로그인 상태 확인됨")
            return True
        except:
            self.log("로그인이 필요합니다. 수동으로 로그인해주세요.")
            input("로그인 완료 후 엔터를 눌러주세요: ")
            return True
    
    def upload_video(self, video_path, title, description="", is_public=True):
        """실제 YouTube 업로드 실행"""
        driver = None
        try:
            self.log(f"업로드 시작: {video_path.name}")
            
            # Chrome 드라이버 설정
            driver = self.setup_chrome_driver()
            wait = WebDriverWait(driver, 30)
            
            # 로그인 확인
            if not self.wait_for_login(driver):
                return False
            
            # 1. 만들기 버튼 클릭
            self.log("업로드 버튼 클릭...")
            create_button = wait.until(
                EC.element_to_be_clickable((By.XPATH, "//ytcp-button[@id='create-icon']"))
            )
            create_button.click()
            
            # 2. 동영상 업로드 선택
            upload_option = wait.until(
                EC.element_to_be_clickable((By.XPATH, "//tp-yt-paper-item[@test-id='upload-video']"))
            )
            upload_option.click()
            
            # 3. 파일 선택
            self.log("파일 업로드 중...")
            file_input = wait.until(
                EC.presence_of_element_located((By.XPATH, "//input[@type='file']"))
            )
            file_input.send_keys(str(video_path.absolute()))
            
            # 파일 업로드 대기
            time.sleep(5)
            
            # 4. 제목 입력
            self.log("제목 입력 중...")
            title_input = wait.until(
                EC.element_to_be_clickable((By.XPATH, "//div[@id='textbox' and @aria-label='제목을 추가하세요']"))
            )
            title_input.clear()
            title_input.send_keys(title)
            
            # 5. 설명 입력 (선택사항)
            if description:
                self.log("설명 입력 중...")
                try:
                    desc_input = driver.find_element(By.XPATH, "//div[@id='textbox' and @aria-label='시청자에게 영상을 설명하세요']")
                    desc_input.clear()
                    desc_input.send_keys(description)
                except:
                    self.log("설명 입력 건너뜀")
            
            # 6. 다음 단계들 진행
            self.log("업로드 설정 진행...")
            for step in range(3):
                try:
                    next_button = wait.until(
                        EC.element_to_be_clickable((By.XPATH, "//ytcp-button[@id='next-button']"))
                    )
                    next_button.click()
                    time.sleep(2)
                    self.log(f"단계 {step+1}/3 완료")
                except:
                    self.log(f"단계 {step+1} 건너뜀")
            
            # 7. 공개 설정
            if is_public:
                self.log("공개 설정 적용...")
                try:
                    public_radio = wait.until(
                        EC.element_to_be_clickable((By.XPATH, "//tp-yt-paper-radio-button[@name='PUBLIC']"))
                    )
                    public_radio.click()
                except:
                    self.log("공개 설정 실패 (기본값 유지)")
            
            # 8. 게시하기
            self.log("게시 중...")
            publish_button = wait.until(
                EC.element_to_be_clickable((By.XPATH, "//ytcp-button[@id='done-button']"))
            )
            publish_button.click()
            
            # 9. 업로드 완료 대기
            self.log("업로드 완료 대기...")
            time.sleep(15)
            
            # 10. 영상 링크 추출 시도
            try:
                video_link = wait.until(
                    EC.presence_of_element_located((By.XPATH, "//a[contains(@href, '/watch?v=')]"))
                )
                video_url = video_link.get_attribute('href')
                self.log(f"업로드 성공: {video_url}")
                return video_url
            except:
                self.log("업로드 완료 (링크 추출 실패)")
                return True
                
        except Exception as e:
            self.log(f"업로드 실패: {str(e)}", "ERROR")
            return False
        finally:
            if driver:
                driver.quit()
    
    def generate_metadata(self, video_path):
        """영상 메타데이터 생성"""
        # 파일명을 기반으로 제목 생성
        title = video_path.stem.replace('_', ' ').replace('-', ' ').title()
        
        # 설명 생성
        description = f"""
{title}

📹 업로드 정보:
- 파일명: {video_path.name}
- 업로드 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- 자동 업로드: Real YouTube Uploader

#자동업로드 #YouTube #영상
        """.strip()
        
        return title, description
    
    def archive_video(self, video_path):
        """업로드 완료된 영상 보관"""
        try:
            archive_path = self.archive_folder / video_path.name
            shutil.move(str(video_path), str(archive_path))
            self.log(f"영상 보관: {archive_path}")
            return True
        except Exception as e:
            self.log(f"영상 보관 실패: {str(e)}", "ERROR")
            return False
    
    def save_processed_record(self, video_name, result):
        """처리 기록 저장"""
        try:
            if self.processed_file.exists():
                with open(self.processed_file, 'r', encoding='utf-8') as f:
                    records = json.load(f)
            else:
                records = {}
            
            records[video_name] = {
                'timestamp': datetime.now().isoformat(),
                'result': result,
                'url': result if isinstance(result, str) else None
            }
            
            with open(self.processed_file, 'w', encoding='utf-8') as f:
                json.dump(records, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            self.log(f"기록 저장 실패: {str(e)}", "ERROR")
    
    def process_single_video(self, video_path):
        """단일 영상 처리"""
        try:
            # 메타데이터 생성
            title, description = self.generate_metadata(video_path)
            
            # 업로드 실행
            result = self.upload_video(video_path, title, description)
            
            if result:
                # 성공 시 보관
                self.archive_video(video_path)
                self.save_processed_record(video_path.name, result)
                self.log(f"✅ 처리 완료: {video_path.name}")
                return True
            else:
                self.log(f"❌ 처리 실패: {video_path.name}")
                return False
                
        except Exception as e:
            self.log(f"처리 중 오류: {str(e)}", "ERROR")
            return False
    
    def scan_and_process(self):
        """폴더 스캔 후 처리"""
        video_extensions = ['.mp4', '.mov', '.avi', '.mkv']
        
        for video_file in self.watch_folder.iterdir():
            if (video_file.is_file() and 
                video_file.suffix.lower() in video_extensions):
                
                self.log(f"새 영상 발견: {video_file.name}")
                self.process_single_video(video_file)
    
    def run_continuous(self):
        """지속적 폴더 감시"""
        self.log("지속적 폴더 감시 시작...")
        
        while True:
            try:
                self.scan_and_process()
                time.sleep(60)  # 60초마다 확인
            except KeyboardInterrupt:
                self.log("사용자 중단")
                break
            except Exception as e:
                self.log(f"감시 중 오류: {str(e)}", "ERROR")
                time.sleep(30)

class RealTimeWatcher(FileSystemEventHandler):
    """실시간 파일 감시"""
    def __init__(self, uploader):
        self.uploader = uploader
    
    def on_created(self, event):
        if not event.is_directory:
            file_path = Path(event.src_path)
            if file_path.suffix.lower() in ['.mp4', '.mov', '.avi', '.mkv']:
                self.uploader.log(f"실시간 감지: {file_path.name}")
                time.sleep(5)  # 파일 복사 완료 대기
                self.uploader.process_single_video(file_path)

def main():
    print("🎬 실제 YouTube 자동 업로드 시스템")
    print("=" * 50)
    
    # 업로더 초기화
    uploader = RealYouTubeUploader()
    
    # Chrome 프로필 설정 (선택사항)
    profile_path = input("Chrome 프로필 경로 (엔터로 기본값): ").strip()
    if profile_path:
        uploader.set_chrome_profile(profile_path)
    
    # 실행 모드 선택
    mode = input("""
실행 모드:
1. 단발 처리 (현재 파일들만)
2. 지속적 감시 (60초 간격)
3. 실시간 감시 (즉시 처리)

선택 (1-3): """).strip()
    
    if mode == "1":
        print("📂 단발 처리 모드")
        uploader.scan_and_process()
        
    elif mode == "2":
        print("🔄 지속적 감시 모드")
        uploader.run_continuous()
        
    elif mode == "3":
        print("⚡ 실시간 감시 모드")
        observer = Observer()
        observer.schedule(
            RealTimeWatcher(uploader), 
            str(uploader.watch_folder), 
            recursive=False
        )
        observer.start()
        
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            observer.stop()
        observer.join()
        
    else:
        print("❌ 잘못된 선택")

if __name__ == "__main__":
    main()

# 설치 및 실행 가이드
"""
🔧 설치 방법:

1. 필수 라이브러리 설치:
   pip install selenium webdriver-manager watchdog

2. Chrome 브라우저 설치 (최신 버전)

3. 폴더 구조 생성:
   mkdir upload_videos uploaded_videos logs

4. 실행:
   python real_youtube_uploader.py

📁 사용 방법:

1. upload_videos 폴더에 mp4 파일 넣기
2. 프로그램 실행 시 모드 선택
3. 첫 실행시 YouTube 로그인 (한 번만)
4. 자동 업로드 진행 확인
5. logs 폴더에서 결과 확인

🔐 Chrome 프로필 설정 (중요):

1. Chrome 주소창에 chrome://version 입력
2. 프로필 경로 복사
3. 프로그램 실행 시 경로 입력
4. 로그인 세션 자동 유지

⚠️ 주의사항:

- 첫 실행 시 수동 로그인 필요
- 대용량 파일은 업로드 시간 오래 걸림
- YouTube UI 변경 시 셀렉터 수정 필요
- 헤드리스 모드는 디버깅 후 사용 권장
"""
