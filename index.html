import os
import time
import json
import logging
from datetime import datetime, timedelta
from pathlib import Path
from playwright.sync_api import sync_playwright, TimeoutError
import random

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('youtube_uploader.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class YouTubeUploader:
    def __init__(self, upload_dir="upload_queue", auth_file="auth.json"):
        self.upload_dir = Path(upload_dir)
        self.auth_file = auth_file
        self.upload_dir.mkdir(exist_ok=True)
        self.browser = None
        self.context = None
        self.page = None
        
        # ì—…ë¡œë“œ ì„¤ì •
        self.settings = {
            'privacy': 'private',  # public, unlisted, private
            'category': 'Entertainment',
            'language': 'Korean',
            'auto_chapters': True,
            'auto_captions': True,
            'comments_allowed': True,
            'age_restriction': False
        }
    
    def human_delay(self, min_ms=500, max_ms=2000):
        """ì‚¬ëŒì²˜ëŸ¼ ìì—°ìŠ¤ëŸ¬ìš´ ë”œë ˆì´"""
        delay = random.uniform(min_ms, max_ms) / 1000
        time.sleep(delay)
    
    def safe_click(self, element, description="element", timeout=10000):
        """ì•ˆì „í•œ í´ë¦­ (ì—¬ëŸ¬ ë°©ë²• ì‹œë„)"""
        try:
            # 1. ê¸°ë³¸ í´ë¦­
            element.wait_for(state="visible", timeout=timeout)
            element.click()
            logger.info(f"âœ… Clicked {description}")
            return True
        except TimeoutError:
            logger.warning(f"âš ï¸ Timeout waiting for {description}")
        except Exception as e:
            try:
                # 2. ê°•ì œ í´ë¦­
                element.click(force=True)
                logger.info(f"âœ… Force clicked {description}")
                return True
            except Exception as e2:
                try:
                    # 3. JavaScript í´ë¦­
                    element.evaluate("el => el.click()")
                    logger.info(f"âœ… JS clicked {description}")
                    return True
                except Exception as e3:
                    logger.error(f"âŒ Failed to click {description}: {e3}")
                    return False
    
    def safe_fill(self, element, text, description="field", clear_first=True):
        """ì•ˆì „í•œ í…ìŠ¤íŠ¸ ì…ë ¥"""
        try:
            element.wait_for(state="visible", timeout=10000)
            if clear_first:
                # ê¸°ì¡´ í…ìŠ¤íŠ¸ ì „ì²´ ì„ íƒ í›„ ì‚­ì œ
                element.click()
                element.press("Control+a")
                self.human_delay(100, 300)
            
            # ê¸€ìë³„ë¡œ ì²œì²œíˆ ì…ë ¥ (ë´‡ ê°ì§€ ë°©ì§€)
            for char in text:
                element.type(char, delay=random.uniform(50, 150))
            
            logger.info(f"âœ… Filled {description}: {text[:30]}{'...' if len(text) > 30 else ''}")
            return True
        except Exception as e:
            logger.error(f"âŒ Failed to fill {description}: {e}")
            return False
    
    def wait_for_upload_complete(self, timeout=300):
        """ì—…ë¡œë“œ ì™„ë£Œê¹Œì§€ ëŒ€ê¸°"""
        logger.info("â³ Waiting for video upload to complete...")
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                # ì—…ë¡œë“œ ì§„í–‰ë¥  í™•ì¸
                progress_elements = self.page.locator('.progress-label, [role="progressbar"]')
                if progress_elements.count() > 0:
                    for i in range(progress_elements.count()):
                        element = progress_elements.nth(i)
                        if element.is_visible():
                            text = element.inner_text()
                            if "%" in text:
                                logger.info(f"ğŸ“¤ Upload progress: {text}")
                
                # "Processing" ë˜ëŠ” "Upload complete" ì²´í¬
                processing = self.page.locator('text="Processing"').first
                if processing.is_visible():
                    logger.info("ğŸ”„ Video processing...")
                
                # ì—…ë¡œë“œ ì™„ë£Œ ì‹ í˜¸ë“¤ ì²´í¬
                complete_signals = [
                    'text="Upload complete"',
                    'text="Processing complete"', 
                    '[data-testid="VIDEO_MONETIZATION_MONETIZE"]',
                    'text="Checks complete"'
                ]
                
                for signal in complete_signals:
                    if self.page.locator(signal).count() > 0:
                        logger.info("âœ… Video upload completed!")
                        return True
                
                time.sleep(5)
                
            except Exception as e:
                logger.warning(f"Error checking upload status: {e}")
                time.sleep(5)
        
        logger.warning("âš ï¸ Upload timeout reached")
        return False
    
    def setup_browser(self, headless=False):
        """ë¸Œë¼ìš°ì € ì„¤ì • ë° ì‹œì‘"""
        logger.info("ğŸŒ Setting up browser...")
        
        # ë¸Œë¼ìš°ì € ì‹œì‘ ì˜µì…˜
        browser_options = {
            'headless': headless,
            'args': [
                '--no-sandbox',
                '--disable-blink-features=AutomationControlled',
                '--disable-web-security',
                '--disable-features=VizDisplayCompositor',
                '--disable-extensions',
                '--disable-plugins',
                '--disable-images',  # ì´ë¯¸ì§€ ë¡œë”© ë¹„í™œì„±í™”ë¡œ ì†ë„ í–¥ìƒ
                '--mute-audio',
                '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            ]
        }
        
        try:
            with sync_playwright() as playwright:
                self.browser = playwright.chromium.launch(**browser_options)
                
                # ì»¨í…ìŠ¤íŠ¸ ì„¤ì • (ì¸ì¦ ì •ë³´ í¬í•¨)
                context_options = {
                    'viewport': {'width': 1920, 'height': 1080},
                    'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'java_script_enabled': True,
                    'accept_downloads': True
                }
                
                if os.path.exists(self.auth_file):
                    context_options['storage_state'] = self.auth_file
                    logger.info("ğŸ”‘ Loaded authentication session")
                
                self.context = self.browser.new_context(**context_options)
                
                # ìë™í™” ê°ì§€ ë°©ì§€
                self.context.add_init_script("""
                    Object.defineProperty(navigator, 'webdriver', {
                        get: () => undefined,
                    });
                    
                    window.chrome = {
                        runtime: {},
                    };
                    
                    Object.defineProperty(navigator, 'plugins', {
                        get: () => [1, 2, 3, 4, 5],
                    });
                    
                    Object.defineProperty(navigator, 'languages', {
                        get: () => ['ko-KR', 'ko', 'en-US', 'en'],
                    });
                """)
                
                self.page = self.context.new_page()
                
                # í˜ì´ì§€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                self.page.on("dialog", lambda dialog: dialog.accept())
                self.page.on("console", lambda msg: logger.debug(f"Console: {msg.text}"))
                
                return True
                
        except Exception as e:
            logger.error(f"âŒ Browser setup failed: {e}")
            return False
    
    def authenticate(self):
        """YouTube ì¸ì¦ (ë¡œê·¸ì¸)"""
        if os.path.exists(self.auth_file):
            logger.info("ğŸ”‘ Authentication file exists, skipping login")
            return True
        
        logger.info("ğŸ” Starting authentication process...")
        
        try:
            # YouTube Studioë¡œ ì´ë™
            self.page.goto("https://studio.youtube.com", wait_until="domcontentloaded")
            self.human_delay(3000, 5000)
            
            # ë¡œê·¸ì¸ ì²´í¬
            if "accounts.google.com" in self.page.url:
                print("\n" + "="*60)
                print("ğŸ” YOUTUBE LOGIN REQUIRED")
                print("="*60)
                print("1. êµ¬ê¸€ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì„¸ìš”")
                print("2. 2ë‹¨ê³„ ì¸ì¦ì´ ìˆë‹¤ë©´ ì™„ë£Œí•˜ì„¸ìš”")
                print("3. YouTube Studio ë©”ì¸ í˜ì´ì§€ê°€ ë¡œë“œë˜ë©´ Enterë¥¼ ëˆ„ë¥´ì„¸ìš”")
                print("="*60)
                
                input("ë¡œê·¸ì¸ ì™„ë£Œ í›„ Enterë¥¼ ëˆ„ë¥´ì„¸ìš”...")
            
            # ì¸ì¦ ìƒíƒœ ì €ì¥
            self.context.storage_state(path=self.auth_file)
            logger.info(f"âœ… Authentication saved to {self.auth_file}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Authentication failed: {e}")
            return False
    
    def navigate_to_upload(self):
        """ì—…ë¡œë“œ í˜ì´ì§€ë¡œ ì´ë™"""
        logger.info("ğŸ“¤ Navigating to upload page...")
        
        try:
            # YouTube Studio ë©”ì¸ í˜ì´ì§€
            self.page.goto("https://studio.youtube.com", wait_until="domcontentloaded")
            self.human_delay(2000, 4000)
            
            # CREATE ë²„íŠ¼ í´ë¦­
            create_selectors = [
                '[aria-label="ë§Œë“¤ê¸°"]',
                '[aria-label="Create"]',
                'text="CREATE"',
                '#create-icon',
                'ytcp-icon-button[aria-label*="Create"]'
            ]
            
            for selector in create_selectors:
                try:
                    create_btn = self.page.locator(selector).first
                    if create_btn.is_visible():
                        self.safe_click(create_btn, "Create button")
                        break
                except:
                    continue
            
            self.human_delay(1000, 2000)
            
            # "ë™ì˜ìƒ ì—…ë¡œë“œ" ì˜µì…˜ í´ë¦­
            upload_selectors = [
                'text="ë™ì˜ìƒ ì—…ë¡œë“œ"',
                'text="Upload video"',
                'text="Upload videos"',
                '[aria-label*="Upload"]'
            ]
            
            for selector in upload_selectors:
                try:
                    upload_btn = self.page.locator(selector).first
                    if upload_btn.is_visible():
                        self.safe_click(upload_btn, "Upload video button")
                        break
                except:
                    continue
            
            self.human_delay(2000, 3000)
            return True
            
        except Exception as e:
            logger.error(f"âŒ Failed to navigate to upload: {e}")
            return False
    
    def upload_file(self, video_path):
        """ë¹„ë””ì˜¤ íŒŒì¼ ì—…ë¡œë“œ"""
        logger.info(f"ğŸ“ Uploading video file: {video_path}")
        
        try:
            # íŒŒì¼ ì…ë ¥ ìš”ì†Œ ì°¾ê¸°
            file_selectors = [
                'input[type="file"]',
                'input[accept*="video"]',
                '[data-testid="file-input"]'
            ]
            
            for selector in file_selectors:
                try:
                    file_input = self.page.locator(selector).first
                    if file_input.count() > 0:
                        file_input.set_input_files(str(video_path))
                        logger.info("âœ… Video file selected")
                        return True
                except:
                    continue
            
            # ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜ì—­ ì°¾ê¸°
            drop_selectors = [
                '[data-testid="file-drop-zone"]',
                '.file-drop-zone',
                'text="íŒŒì¼ì„ ì„ íƒí•˜ê±°ë‚˜ ì—¬ê¸°ë¡œ ë“œë˜ê·¸í•˜ì„¸ìš”"'
            ]
            
            for selector in drop_selectors:
                try:
                    drop_zone = self.page.locator(selector).first
                    if drop_zone.is_visible():
                        # íŒŒì¼ì„ ë“œë¡­ì¡´ì— ë“œë˜ê·¸
                        drop_zone.set_input_files(str(video_path))
                        logger.info("âœ… Video file dropped")
                        return True
                except:
                    continue
            
            logger.error("âŒ Could not find file upload element")
            return False
            
        except Exception as e:
            logger.error(f"âŒ File upload failed: {e}")
            return False
    
    def fill_metadata(self, title, description, thumbnail_path=None):
        """ë©”íƒ€ë°ì´í„° ì…ë ¥ (ì œëª©, ì„¤ëª…, ì¸ë„¤ì¼)"""
        logger.info("ğŸ“ Filling video metadata...")
        
        try:
            # ì œëª© ì…ë ¥
            title_selectors = [
                '[aria-label="ì œëª©"]',
                '[aria-label="Title"]',
                '#textbox[aria-label*="title" i]',
                'div[contenteditable="true"]'
            ]
            
            for selector in title_selectors:
                try:
                    title_field = self.page.locator(selector).first
                    if title_field.is_visible():
                        self.safe_fill(title_field, title, "title")
                        break
                except:
                    continue
            
            self.human_delay(1000, 2000)
            
            # ì„¤ëª… ì…ë ¥
            description_selectors = [
                '[aria-label="ì„¤ëª…"]',
                '[aria-label="Description"]',
                '#description-textarea',
                'div[contenteditable="true"]:not([aria-label*="title" i])'
            ]
            
            for selector in description_selectors:
                try:
                    desc_field = self.page.locator(selector).first
                    if desc_field.is_visible():
                        self.safe_fill(desc_field, description, "description")
                        break
                except:
                    continue
            
            # ì¸ë„¤ì¼ ì—…ë¡œë“œ
            if thumbnail_path and Path(thumbnail_path).exists():
                self.upload_thumbnail(thumbnail_path)
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ Metadata fill failed: {e}")
            return False
    
    def upload_thumbnail(self, thumbnail_path):
        """ì¸ë„¤ì¼ ì—…ë¡œë“œ"""
        logger.info(f"ğŸ–¼ï¸ Uploading thumbnail: {thumbnail_path}")
        
        try:
            thumbnail_selectors = [
                'text="ì¸ë„¤ì¼ ì—…ë¡œë“œ"',
                'text="Upload thumbnail"',
                '[aria-label*="thumbnail"]',
                'input[accept*="image"]'
            ]
            
            for selector in thumbnail_selectors:
                try:
                    thumb_btn = self.page.locator(selector).first
                    if thumb_btn.is_visible():
                        if "input" in selector:
                            thumb_btn.set_input_files(str(thumbnail_path))
                        else:
                            self.safe_click(thumb_btn, "thumbnail upload button")
                            self.human_delay(500, 1000)
                            
                            # íŒŒì¼ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸
                            file_input = self.page.locator('input[type="file"]').last
                            file_input.set_input_files(str(thumbnail_path))
                        
                        logger.info("âœ… Thumbnail uploaded")
                        return True
                except:
                    continue
            
            logger.warning("âš ï¸ Thumbnail upload skipped (element not found)")
            return False
            
        except Exception as e:
            logger.warning(f"âš ï¸ Thumbnail upload failed: {e}")
            return False
    
    def configure_settings(self):
        """ë¹„ë””ì˜¤ ì„¤ì • êµ¬ì„±"""
        logger.info("âš™ï¸ Configuring video settings...")
        
        try:
            # "ë‹¤ìŒ" ë²„íŠ¼ë“¤ í´ë¦­í•˜ì—¬ ì„¤ì • í˜ì´ì§€ë“¤ë¡œ ì´ë™
            for step in range(4):
                next_selectors = [
                    'text="ë‹¤ìŒ"',
                    'text="Next"',
                    '[aria-label="ë‹¤ìŒ"]',
                    '[aria-label="Next"]',
                    'ytcp-button[aria-label*="next" i]'
                ]
                
                for selector in next_selectors:
                    try:
                        next_btn = self.page.locator(selector).first
                        if next_btn.is_visible():
                            self.safe_click(next_btn, f"Next button (step {step+1})")
                            self.human_delay(2000, 3000)
                            break
                    except:
                        continue
                
                # ê° ë‹¨ê³„ë³„ ì„¤ì •
                if step == 1:  # ë™ì˜ìƒ ìš”ì†Œ
                    self.configure_video_elements()
                elif step == 2:  # ê³µê°œ ìƒíƒœ
                    self.configure_visibility()
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ Settings configuration failed: {e}")
            return False
    
    def configure_video_elements(self):
        """ë™ì˜ìƒ ìš”ì†Œ ì„¤ì •"""
        try:
            # ìë™ ì±•í„° ì„¤ì •
            if self.settings['auto_chapters']:
                auto_chapters = self.page.locator('text="ìë™ ì±•í„°"').first
                if auto_chapters.is_visible():
                    checkbox = auto_chapters.locator('..').locator('tp-yt-paper-checkbox')
                    if not checkbox.get_attribute('checked'):
                        self.safe_click(checkbox, "auto chapters")
            
            # ìë™ ìë§‰ ì„¤ì •
            if self.settings['auto_captions']:
                auto_captions = self.page.locator('text="ìë™ ìë§‰"').first
                if auto_captions.is_visible():
                    checkbox = auto_captions.locator('..').locator('tp-yt-paper-checkbox')
                    if not checkbox.get_attribute('checked'):
                        self.safe_click(checkbox, "auto captions")
            
            logger.info("âœ… Video elements configured")
            
        except Exception as e:
            logger.warning(f"âš ï¸ Video elements configuration failed: {e}")
    
    def configure_visibility(self):
        """ê³µê°œ ìƒíƒœ ì„¤ì •"""
        try:
            privacy_options = {
                'private': ['ë¹„ê³µê°œ', 'Private'],
                'unlisted': ['ëª©ë¡ì— ì—†ìŒ', 'Unlisted'], 
                'public': ['ê³µê°œ', 'Public']
            }
            
            target_privacy = privacy_options.get(self.settings['privacy'], ['ë¹„ê³µê°œ', 'Private'])
            
            for privacy_text in target_privacy:
                try:
                    privacy_btn = self.page.locator(f'text="{privacy_text}"').first
                    if privacy_btn.is_visible():
                        self.safe_click(privacy_btn, f"privacy: {privacy_text}")
                        break
                except:
                    continue
            
            logger.info(f"âœ… Privacy set to: {self.settings['privacy']}")
            
        except Exception as e:
            logger.warning(f"âš ï¸ Privacy configuration failed: {e}")
    
    def schedule_video(self, schedule_datetime):
        """ë¹„ë””ì˜¤ ì˜ˆì•½"""
        logger.info(f"ğŸ“… Scheduling video for: {schedule_datetime}")
        
        try:
            # ì˜ˆì•½ ë¼ë””ì˜¤ ë²„íŠ¼ ì„ íƒ
            schedule_selectors = [
                'text="ì˜ˆì•½"',
                'text="Schedule"',
                '[aria-label*="schedule" i]'
            ]
            
            for selector in schedule_selectors:
                try:
                    schedule_radio = self.page.locator(selector).first
                    if schedule_radio.is_visible():
                        self.safe_click(schedule_radio, "schedule radio")
                        break
                except:
                    continue
            
            self.human_delay(1000, 2000)
            
            # ë‚ ì§œ ì…ë ¥
            date_str = schedule_datetime.strftime("%Y-%m-%d")
            date_selectors = [
                '[aria-label*="ë‚ ì§œ"]',
                '[aria-label*="date" i]',
                'input[type="date"]'
            ]
            
            for selector in date_selectors:
                try:
                    date_field = self.page.locator(selector).first
                    if date_field.is_visible():
                        self.safe_fill(date_field, date_str, "date")
                        break
                except:
                    continue
            
            # ì‹œê°„ ì…ë ¥
            time_str = schedule_datetime.strftime("%H:%M")
            time_selectors = [
                '[aria-label*="ì‹œê°„"]',
                '[aria-label*="time" i]',
                'input[type="time"]'
            ]
            
            for selector in time_selectors:
                try:
                    time_field = self.page.locator(selector).first
                    if time_field.is_visible():
                        self.safe_fill(time_field, time_str, "time")
                        break
                except:
                    continue
            
            logger.info(f"âœ… Video scheduled for: {date_str} {time_str}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Scheduling failed: {e}")
            return False
    
    def publish_video(self, is_scheduled=False):
        """ë¹„ë””ì˜¤ ê²Œì‹œ"""
        action = "scheduled" if is_scheduled else "published"
        logger.info(f"ğŸš€ Publishing video ({action})...")
        
        try:
            publish_selectors = [
                'text="ì˜ˆì•½"' if is_scheduled else 'text="ê²Œì‹œ"',
                'text="Schedule"' if is_scheduled else 'text="Publish"',
                '[aria-label*="publish" i]',
                'ytcp-button[aria-label*="publish" i]'
            ]
            
            for selector in publish_selectors:
                try:
                    publish_btn = self.page.locator(selector).first
                    if publish_btn.is_visible():
                        self.safe_click(publish_btn, f"publish button ({action})")
                        self.human_delay(3000, 5000)
                        return True
                except:
                    continue
            
            logger.error(f"âŒ Publish button not found")
            return False
            
        except Exception as e:
            logger.error(f"âŒ Publishing failed: {e}")
            return False
    
    def upload_single_video(self, video_config):
        """ë‹¨ì¼ ë¹„ë””ì˜¤ ì—…ë¡œë“œ í”„ë¡œì„¸ìŠ¤"""
        video_id = video_config['id']
        logger.info(f"ğŸ¬ Starting upload for video: {video_id}")
        
        try:
            # 1. ì—…ë¡œë“œ í˜ì´ì§€ë¡œ ì´ë™
            if not self.navigate_to_upload():
                return False
            
            # 2. íŒŒì¼ ì—…ë¡œë“œ
            if not self.upload_file(video_config['video_path']):
                return False
            
            # 3. ì—…ë¡œë“œ ì™„ë£Œ ëŒ€ê¸°
            if not self.wait_for_upload_complete():
                logger.warning("âš ï¸ Upload may not be complete, continuing...")
            
            # 4. ë©”íƒ€ë°ì´í„° ì…ë ¥
            if not self.fill_metadata(
                video_config['title'],
                video_config['description'], 
                video_config.get('thumbnail_path')
            ):
                return False
            
            # 5. ì„¤ì • êµ¬ì„±
            if not self.configure_settings():
                return False
            
            # 6. ì˜ˆì•½ ì„¤ì • (ìˆëŠ” ê²½ìš°)
            if video_config.get('schedule_datetime'):
                if not self.schedule_video(video_config['schedule_datetime']):
                    return False
                is_scheduled = True
            else:
                is_scheduled = False
            
            # 7. ê²Œì‹œ
            if not self.publish_video(is_scheduled):
                return False
            
            logger.info(f"âœ… Video {video_id} uploaded successfully!")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Upload failed for {video_id}: {e}")
            return False
    
    def load_video_configs(self):
        """ë¹„ë””ì˜¤ ì„¤ì • íŒŒì¼ë“¤ ë¡œë“œ"""
        configs = []
        
        # upload_queue í´ë”ì—ì„œ ë¹„ë””ì˜¤ íŒŒì¼ë“¤ ì°¾ê¸°
        video_files = list(self.upload_dir.glob("*_video.mp4"))
        
        for video_file in video_files:
            video_id = video_file.stem.replace("_video", "")
            
            try:
                # í•„ìˆ˜ íŒŒì¼ë“¤ í™•ì¸
                title_file = self.upload_dir / f"{video_id}_title.txt"
                desc_file = self.upload_dir / f"{video_id}_description.txt"
                
                if not title_file.exists() or not desc_file.exists():
                    logger.warning(f"âš ï¸ Missing files for {video_id}, skipping")
                    continue
                
                config = {
                    'id': video_id,
                    'video_path': video_file,
                    'title': title_file.read_text(encoding='utf-8').strip(),
                    'description': desc_file.read_text(encoding='utf-8').strip()
                }
                
                # ì„ íƒì  íŒŒì¼ë“¤
                thumbnail_file = self.upload_dir / f"{video_id}_thumbnail.jpg"
                if thumbnail_file.exists():
                    config['thumbnail_path'] = thumbnail_file
                
                schedule_file = self.upload_dir / f"{video_id}_schedule.txt"
                if schedule_file.exists():
                    schedule_str = schedule_file.read_text(encoding='utf-8').strip()
                    try:
                        config['schedule_datetime'] = datetime.strptime(schedule_str, "%Y-%m-%d %H:%M")
                    except ValueError:
                        logger.warning(f"âš ï¸ Invalid schedule format for {video_id}: {schedule_str}")
                
                configs.append(config)
                logger.info(f"ğŸ“‹ Loaded config for {video_id}")
                
            except Exception as e:
                logger.error(f"âŒ Failed to load config for {video_id}: {e}")
        
        return configs
    
    def run(self, headless=False):
        """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
        logger.info("ğŸš€ Starting YouTube Auto Uploader...")
        
        try:
            # ë¸Œë¼ìš°ì € ì„¤ì •
            if not self.setup_browser(headless):
                return False
            
            # ì¸ì¦
            if not self.authenticate():
                return False
            
            # ë¹„ë””ì˜¤ ì„¤ì • ë¡œë“œ
            video_configs = self.load_video_configs()
            if not video_configs:
                logger.warning("âš ï¸ No videos found to upload")
                return False
            
            logger.info(f"ğŸ“¹ Found {len(video_configs)} videos to upload")
            
            # ì—…ë¡œë“œ ì‹¤í–‰
            success_count = 0
            for config in video_configs:
                if self.upload_single_video(config):
                    success_count += 1
                
                # ë‹¤ìŒ ì—…ë¡œë“œ ì „ ëŒ€ê¸° (ë´‡ ê°ì§€ ë°©ì§€)
                if config != video_configs[-1]:  # ë§ˆì§€ë§‰ì´ ì•„ë‹ˆë©´
                    wait_time = random.uniform(30, 90)  # 30-90ì´ˆ ëŒ€ê¸°
                    logger.info(f"â³ Waiting {wait_time:.1f}s before next upload...")
                    time.sleep(wait_time)
            
            logger.info(f"ğŸ‰ Upload completed: {success_count}/{len(video_configs)} successful")
            return success_count > 0
            
        except Exception as e:
            logger.error(f"âŒ Fatal error: {e}")
            return False
        
        finally:
            # ë¸Œë¼ìš°ì € ì •ë¦¬
            if self.browser:
                self.browser.close()
                logger.info("ğŸ”’ Browser closed")

def create_sample_files():
    """ìƒ˜í”Œ íŒŒì¼ ìƒì„±"""
    upload_dir = Path("upload_queue")
    upload_dir.mkdir(exist_ok=True)
    
    samples = {
        "sample1_title.txt": "ë‚´ ì²« ë²ˆì§¸ ìœ íŠœë¸Œ ë¹„ë””ì˜¤",
        "sample1_description.txt": """ì•ˆë…•í•˜ì„¸ìš”! ì´ê²ƒì€ ìë™ ì—…ë¡œë“œëœ ë¹„ë””ì˜¤ì…ë‹ˆë‹¤.

ğŸ¯ ì£¼ìš” ë‚´ìš©:
- ìë™í™”ëœ ì—…ë¡œë“œ ì‹œìŠ¤í…œ
- ì˜ˆì•½ ê²Œì‹œ ê¸°ëŠ¥
- ì™„ì „í•œ ë©”íƒ€ë°ì´í„° ê´€ë¦¬

#ìë™ì—…ë¡œë“œ #YouTube #ìë™í™” #í”„ë¡œê·¸ë˜ë°""",
        "sample1_schedule.txt": (datetime.now() + timedelta(hours=1)).strftime("%Y-%m-%d %H:%M")
    }
    
    for filename, content in samples.items():
        filepath = upload_dir / filename
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(content)
    
    print(f"\nâœ… Sample files created in {upload_dir}/")
    print("ğŸ“‹ Next steps:")
    print("1. Add your video file as 'sample1_video.mp4'")
    print("2. Optionally add 'sample1_thumbnail.jpg'")
    print("3. Run the script again")
    print("4. Log in to YouTube when prompted")

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="YouTube Auto Uploader")
    parser.add_argument("--headless", action="store_true", help="Run in headless mode")
    parser.add_argument("--create-samples", action="store_true", help="Create sample files")
    parser.add_argument("--privacy", choices=['public', 'unlisted', 'private'], 
                       default='private', help="Default privacy setting")
    args = parser.parse_args()
    
    if args.create_samples:
        create_sample_files()
    else:
        uploader = YouTubeUploader()
        uploader.settings['privacy'] = args.privacy
        
        # ì—…ë¡œë“œí•  ë¹„ë””ì˜¤ê°€ ìˆëŠ”ì§€ í™•ì¸
        if not list(uploader.upload_dir.glob("*_video.mp4")):
            print("âŒ No video files found!")
            print("ğŸ“‹ Use --create-samples to generate sample files")
            print("ğŸ“ Or add video files to upload_queue/ folder")
        else:
            uploader.run(headless=args.headless)


class YouTubeUploaderGUI:
    """GUI ì¸í„°í˜ì´ìŠ¤ (ì„ íƒì‚¬í•­)"""
    
    def __init__(self):
        try:
            import tkinter as tk
            from tkinter import ttk, filedialog, messagebox
            self.tk = tk
            self.ttk = ttk
            self.filedialog = filedialog
            self.messagebox = messagebox
        except ImportError:
            logger.error("âŒ tkinter not available. GUI mode disabled.")
            return
        
        self.uploader = YouTubeUploader()
        self.create_gui()
    
    def create_gui(self):
        """GUI ìƒì„±"""
        self.root = self.tk.Tk()
        self.root.title("YouTube Auto Uploader")
        self.root.geometry("800x600")
        
        # ë©”ì¸ í”„ë ˆì„
        main_frame = self.ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(self.tk.W, self.tk.E, self.tk.N, self.tk.S))
        
        # íŒŒì¼ ì„ íƒ ì„¹ì…˜
        file_frame = self.ttk.LabelFrame(main_frame, text="ğŸ“ File Selection", padding="10")
        file_frame.grid(row=0, column=0, columnspan=2, sticky=(self.tk.W, self.tk.E), pady=5)
        
        self.ttk.Button(file_frame, text="ğŸ“¹ Select Video", 
                       command=self.select_video).grid(row=0, column=0, padx=5)
        self.ttk.Button(file_frame, text="ğŸ–¼ï¸ Select Thumbnail", 
                       command=self.select_thumbnail).grid(row=0, column=1, padx=5)
        
        self.video_label = self.ttk.Label(file_frame, text="No video selected")
        self.video_label.grid(row=1, column=0, columnspan=2, pady=5)
        
        # ë©”íƒ€ë°ì´í„° ì„¹ì…˜
        meta_frame = self.ttk.LabelFrame(main_frame, text="ğŸ“ Video Metadata", padding="10")
        meta_frame.grid(row=1, column=0, columnspan=2, sticky=(self.tk.W, self.tk.E), pady=5)
        
        self.ttk.Label(meta_frame, text="Title:").grid(row=0, column=0, sticky=self.tk.W)
        self.title_entry = self.ttk.Entry(meta_frame, width=60)
        self.title_entry.grid(row=0, column=1, padx=5, pady=2)
        
        self.ttk.Label(meta_frame, text="Description:").grid(row=1, column=0, sticky=self.tk.NW)
        self.description_text = self.tk.Text(meta_frame, width=60, height=8)
        self.description_text.grid(row=1, column=1, padx=5, pady=2)
        
        # ì„¤ì • ì„¹ì…˜
        settings_frame = self.ttk.LabelFrame(main_frame, text="âš™ï¸ Settings", padding="10")
        settings_frame.grid(row=2, column=0, columnspan=2, sticky=(self.tk.W, self.tk.E), pady=5)
        
        self.ttk.Label(settings_frame, text="Privacy:").grid(row=0, column=0, sticky=self.tk.W)
        self.privacy_var = self.tk.StringVar(value="private")
        privacy_combo = self.ttk.Combobox(settings_frame, textvariable=self.privacy_var,
                                         values=["public", "unlisted", "private"])
        privacy_combo.grid(row=0, column=1, padx=5)
        
        self.ttk.Label(settings_frame, text="Schedule:").grid(row=1, column=0, sticky=self.tk.W)
        self.schedule_var = self.tk.BooleanVar()
        self.ttk.Checkbutton(settings_frame, variable=self.schedule_var,
                            command=self.toggle_schedule).grid(row=1, column=1, sticky=self.tk.W)
        
        self.schedule_frame = self.ttk.Frame(settings_frame)
        self.schedule_frame.grid(row=2, column=0, columnspan=2, sticky=(self.tk.W, self.tk.E))
        
        self.ttk.Label(self.schedule_frame, text="Date:").grid(row=0, column=0)
        self.date_entry = self.ttk.Entry(self.schedule_frame, width=15)
        self.date_entry.grid(row=0, column=1, padx=5)
        self.date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        
        self.ttk.Label(self.schedule_frame, text="Time:").grid(row=0, column=2)
        self.time_entry = self.ttk.Entry(self.schedule_frame, width=10)
        self.time_entry.grid(row=0, column=3, padx=5)
        self.time_entry.insert(0, (datetime.now() + timedelta(hours=1)).strftime("%H:%M"))
        
        # ì´ˆê¸°ì—ëŠ” ìŠ¤ì¼€ì¤„ í”„ë ˆì„ ìˆ¨ê¹€
        self.toggle_schedule()
        
        # ì—…ë¡œë“œ ë²„íŠ¼
        upload_frame = self.ttk.Frame(main_frame)
        upload_frame.grid(row=3, column=0, columnspan=2, pady=20)
        
        self.ttk.Button(upload_frame, text="ğŸš€ Upload Now", 
                       command=self.upload_now).grid(row=0, column=0, padx=10)
        self.ttk.Button(upload_frame, text="ğŸ“‹ Add to Queue", 
                       command=self.add_to_queue).grid(row=0, column=1, padx=10)
        self.ttk.Button(upload_frame, text="ğŸ¬ Process Queue", 
                       command=self.process_queue).grid(row=0, column=2, padx=10)
        
        # ë¡œê·¸ ì˜ì—­
        log_frame = self.ttk.LabelFrame(main_frame, text="ğŸ“„ Log", padding="10")
        log_frame.grid(row=4, column=0, columnspan=2, sticky=(self.tk.W, self.tk.E, self.tk.N, self.tk.S), pady=5)
        
        self.log_text = self.tk.Text(log_frame, width=80, height=10)
        scrollbar = self.ttk.Scrollbar(log_frame, orient="vertical", command=self.log_text.yview)
        self.log_text.configure(yscrollcommand=scrollbar.set)
        
        self.log_text.grid(row=0, column=0, sticky=(self.tk.W, self.tk.E, self.tk.N, self.tk.S))
        scrollbar.grid(row=0, column=1, sticky=(self.tk.N, self.tk.S))
        
        # ê·¸ë¦¬ë“œ ê°€ì¤‘ì¹˜ ì„¤ì •
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(4, weight=1)
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
        
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        
        # ë³€ìˆ˜ ì´ˆê¸°í™”
        self.video_path = None
        self.thumbnail_path = None
    
    def toggle_schedule(self):
        """ìŠ¤ì¼€ì¤„ ì„¤ì • í† ê¸€"""
        if self.schedule_var.get():
            for child in self.schedule_frame.winfo_children():
                child.grid()
        else:
            for child in self.schedule_frame.winfo_children():
                child.grid_remove()
    
    def select_video(self):
        """ë¹„ë””ì˜¤ íŒŒì¼ ì„ íƒ"""
        file_path = self.filedialog.askopenfilename(
            title="Select Video File",
            filetypes=[("Video files", "*.mp4 *.avi *.mov *.mkv"), ("All files", "*.*")]
        )
        if file_path:
            self.video_path = file_path
            self.video_label.config(text=f"ğŸ“¹ {Path(file_path).name}")
    
    def select_thumbnail(self):
        """ì¸ë„¤ì¼ íŒŒì¼ ì„ íƒ"""
        file_path = self.filedialog.askopenfilename(
            title="Select Thumbnail Image",
            filetypes=[("Image files", "*.jpg *.jpeg *.png"), ("All files", "*.*")]
        )
        if file_path:
            self.thumbnail_path = file_path
            self.log(f"ğŸ–¼ï¸ Thumbnail selected: {Path(file_path).name}")
    
    def log(self, message):
        """ë¡œê·¸ ë©”ì‹œì§€ ì¶”ê°€"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_text.insert(self.tk.END, f"[{timestamp}] {message}\n")
        self.log_text.see(self.tk.END)
        self.root.update()
    
    def validate_inputs(self):
        """ì…ë ¥ê°’ ê²€ì¦"""
        if not self.video_path:
            self.messagebox.showerror("Error", "Please select a video file")
            return False
        
        if not self.title_entry.get().strip():
            self.messagebox.showerror("Error", "Please enter a video title")
            return False
        
        return True
    
    def get_video_config(self):
        """í˜„ì¬ ì…ë ¥ê°’ìœ¼ë¡œ ë¹„ë””ì˜¤ ì„¤ì • ìƒì„±"""
        config = {
            'video_path': Path(self.video_path),
            'title': self.title_entry.get().strip(),
            'description': self.description_text.get("1.0", self.tk.END).strip()
        }
        
        if self.thumbnail_path:
            config['thumbnail_path'] = Path(self.thumbnail_path)
        
        if self.schedule_var.get():
            try:
                date_str = self.date_entry.get()
                time_str = self.time_entry.get()
                schedule_str = f"{date_str} {time_str}"
                config['schedule_datetime'] = datetime.strptime(schedule_str, "%Y-%m-%d %H:%M")
            except ValueError:
                self.messagebox.showerror("Error", "Invalid date/time format")
                return None
        
        return config
    
    def upload_now(self):
        """ì¦‰ì‹œ ì—…ë¡œë“œ"""
        if not self.validate_inputs():
            return
        
        config = self.get_video_config()
        if not config:
            return
        
        self.log("ğŸš€ Starting immediate upload...")
        
        try:
            # ì„¤ì • ì ìš©
            self.uploader.settings['privacy'] = self.privacy_var.get()
            
            # ë¸Œë¼ìš°ì € ì‹œì‘
            if not self.uploader.setup_browser():
                self.log("âŒ Failed to setup browser")
                return
            
            # ì¸ì¦
            if not self.uploader.authenticate():
                self.log("âŒ Authentication failed")
                return
            
            # ì—…ë¡œë“œ
            config['id'] = f"gui_upload_{int(time.time())}"
            if self.uploader.upload_single_video(config):
                self.log("âœ… Upload completed successfully!")
                self.messagebox.showinfo("Success", "Video uploaded successfully!")
            else:
                self.log("âŒ Upload failed")
                self.messagebox.showerror("Error", "Upload failed. Check logs for details.")
                
        except Exception as e:
            self.log(f"âŒ Error: {e}")
            self.messagebox.showerror("Error", f"An error occurred: {e}")
        finally:
            if self.uploader.browser:
                self.uploader.browser.close()
    
    def add_to_queue(self):
        """íì— ì¶”ê°€"""
        if not self.validate_inputs():
            return
        
        config = self.get_video_config()
        if not config:
            return
        
        try:
            # í ë””ë ‰í† ë¦¬ ìƒì„±
            self.uploader.upload_dir.mkdir(exist_ok=True)
            
            # íŒŒì¼ ID ìƒì„±
            timestamp = int(time.time())
            file_id = f"queue_{timestamp}"
            
            # ë¹„ë””ì˜¤ íŒŒì¼ ë³µì‚¬
            video_dest = self.uploader.upload_dir / f"{file_id}_video.mp4"
            import shutil
            shutil.copy2(config['video_path'], video_dest)
            
            # ë©”íƒ€ë°ì´í„° íŒŒì¼ ìƒì„±
            (self.uploader.upload_dir / f"{file_id}_title.txt").write_text(
                config['title'], encoding='utf-8')
            (self.uploader.upload_dir / f"{file_id}_description.txt").write_text(
                config['description'], encoding='utf-8')
            
            # ì¸ë„¤ì¼ ë³µì‚¬ (ìˆëŠ” ê²½ìš°)
            if config.get('thumbnail_path'):
                thumb_dest = self.uploader.upload_dir / f"{file_id}_thumbnail.jpg"
                shutil.copy2(config['thumbnail_path'], thumb_dest)
            
            # ìŠ¤ì¼€ì¤„ íŒŒì¼ ìƒì„± (ìˆëŠ” ê²½ìš°)
            if config.get('schedule_datetime'):
                schedule_str = config['schedule_datetime'].strftime("%Y-%m-%d %H:%M")
                (self.uploader.upload_dir / f"{file_id}_schedule.txt").write_text(
                    schedule_str, encoding='utf-8')
            
            self.log(f"âœ… Added to queue: {file_id}")
            self.messagebox.showinfo("Success", "Video added to upload queue!")
            
        except Exception as e:
            self.log(f"âŒ Error adding to queue: {e}")
            self.messagebox.showerror("Error", f"Failed to add to queue: {e}")
    
    def process_queue(self):
        """í ì²˜ë¦¬"""
        self.log("ğŸ¬ Processing upload queue...")
        
        try:
            self.uploader.settings['privacy'] = self.privacy_var.get()
            success = self.uploader.run()
            
            if success:
                self.log("âœ… Queue processing completed!")
                self.messagebox.showinfo("Success", "All uploads completed!")
            else:
                self.log("âŒ Queue processing failed")
                self.messagebox.showerror("Error", "Queue processing failed")
                
        except Exception as e:
            self.log(f"âŒ Error processing queue: {e}")
            self.messagebox.showerror("Error", f"Queue processing error: {e}")
    
    def run(self):
        """GUI ì‹¤í–‰"""
        self.root.mainloop()


# ì¶”ê°€ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
def batch_create_configs(video_folder, output_folder="upload_queue"):
    """í´ë”ì˜ ëª¨ë“  ë¹„ë””ì˜¤ì— ëŒ€í•´ ì„¤ì • íŒŒì¼ ì¼ê´„ ìƒì„±"""
    video_folder = Path(video_folder)
    output_folder = Path(output_folder)
    output_folder.mkdir(exist_ok=True)
    
    video_files = list(video_folder.glob("*.mp4"))
    
    for i, video_file in enumerate(video_files, 1):
        file_id = f"batch_{i:03d}"
        
        # ë¹„ë””ì˜¤ íŒŒì¼ ë³µì‚¬
        video_dest = output_folder / f"{file_id}_video.mp4"
        import shutil
        shutil.copy2(video_file, video_dest)
        
        # ê¸°ë³¸ ë©”íƒ€ë°ì´í„° ìƒì„±
        title = video_file.stem.replace("_", " ").title()
        (output_folder / f"{file_id}_title.txt").write_text(title, encoding='utf-8')
        
        description = f"""ìë™ ì—…ë¡œë“œëœ ë¹„ë””ì˜¤: {title}

ì—…ë¡œë“œ ë‚ ì§œ: {datetime.now().strftime('%Y-%m-%d')}

#ìë™ì—…ë¡œë“œ #YouTube"""
        (output_folder / f"{file_id}_description.txt").write_text(description, encoding='utf-8')
        
        # 1ì‹œê°„ ê°„ê²©ìœ¼ë¡œ ì˜ˆì•½ ì„¤ì •
        schedule_time = datetime.now() + timedelta(hours=i)
        (output_folder / f"{file_id}_schedule.txt").write_text(
            schedule_time.strftime("%Y-%m-%d %H:%M"), encoding='utf-8')
    
    print(f"âœ… Created configs for {len(video_files)} videos in {output_folder}")


def monitor_folder(watch_folder, upload_folder="upload_queue"):
    """í´ë” ëª¨ë‹ˆí„°ë§í•˜ì—¬ ìƒˆ ë¹„ë””ì˜¤ ìë™ ì²˜ë¦¬"""
    import watchdog
    from watchdog.observers import Observer
    from watchdog.events import FileSystemEventHandler
    
    class VideoHandler(FileSystemEventHandler):
        def __init__(self, upload_folder):
            self.upload_folder = Path(upload_folder)
            self.uploader = YouTubeUploader(self.upload_folder)
        
        def on_created(self, event):
            if event.is_file and event.src_path.endswith('.mp4'):
                logger.info(f"ğŸ¬ New video detected: {event.src_path}")
                self.process_new_video(event.src_path)
        
        def process_new_video(self, video_path):
            try:
                video_path = Path(video_path)
                timestamp = int(time.time())
                file_id = f"auto_{timestamp}"
                
                # ë¹„ë””ì˜¤ íŒŒì¼ ì´ë™
                video_dest = self.upload_folder / f"{file_id}_video.mp4"
                import shutil
                shutil.move(str(video_path), str(video_dest))
                
                # ê¸°ë³¸ ë©”íƒ€ë°ì´í„° ìƒì„±
                title = video_path.stem.replace("_", " ").title()
                (self.upload_folder / f"{file_id}_title.txt").write_text(title, encoding='utf-8')
                
                description = f"ìë™ ê°ì§€ ë° ì—…ë¡œë“œ: {title}"
                (self.upload_folder / f"{file_id}_description.txt").write_text(description, encoding='utf-8')
                
                # 30ë¶„ í›„ ì—…ë¡œë“œ ì˜ˆì•½
                schedule_time = datetime.now() + timedelta(minutes=30)
                (self.upload_folder / f"{file_id}_schedule.txt").write_text(
                    schedule_time.strftime("%Y-%m-%d %H:%M"), encoding='utf-8')
                
                logger.info(f"âœ… Auto-configured video for upload: {file_id}")
                
            except Exception as e:
                logger.error(f"âŒ Auto-processing failed: {e}")
    
    # ëª¨ë‹ˆí„°ë§ ì‹œì‘
    event_handler = VideoHandler(upload_folder)
    observer = Observer()
    observer.schedule(event_handler, str(watch_folder), recursive=False)
    observer.start()
    
    print(f"ğŸ‘ï¸ Monitoring {watch_folder} for new videos...")
    print("Press Ctrl+C to stop")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
        print("\nğŸ“´ Monitoring stopped")
    
    observer.join()
